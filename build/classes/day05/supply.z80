; 
; program supply.pas
; 
CPM:            equ     1               ; Target is CP/M .com file
; 
                include "/Users/joerg/Projekte/pl0/pl0.z80"
; 
                jp      main
; 
; [0] (* Built-ins that do not have to be defined in the compiler itself. *)
; [1] 
; [2] type
; [3]   PBlock = ^TBlock;
; [4]   TBlock = record
; [5]     Next: PBlock;
; [6]     Size: Integer;
; [7]   end;
; [8] 
; [9] var
; [10]   HeapPtr: PBlock absolute '__heapptr';
; [11] 
; [12]   AssertPassed: Integer absolute '__assertpassed';
; [13]   AssertFailed: Integer absolute '__assertfailed';
; [14] 
; [15] procedure FreeMem(P: Pointer; Size: Integer); register; external '__freemem';
; [16] (*var
; [17]   Q: PBlock;
; [18] begin
; [19]   Q := P;
; [20]   Q^.Size := Size;
; [21]   Q^.Next := HeapPtr;
; [22]   HeapPtr := Q;
; [23]   P := nil;
; [24] end;
; [25] *)
; [26] 
; [27] procedure GetMem(var P: Pointer; Size: Integer); register; external '__getmem';
; 
; [28] (*var
; [29]   Q, R: PBlock;
; [30] begin
; [31]   Q := nil;
; [32]   R := HeapPtr;
; [33]   while R <> nil do
; [34]   begin
; [35]     if R^.Size = Size then
; [36]     begin
; [37]       if Q = nil then
; [38]         HeapPtr := R^.Next
; [39]       else
; [40]         Q^.Next := R^.Next;
; [41] 
; [42]       P := R;
; [43] 
; [44]       Exit;
; [45]     end
; [46]     else if R^.Size >= Size + 4 then
; [47]     begin
; [48]       if Q = nil then
; [49]       begin
; [50]         HeapPtr := Ptr(Ord(R) + Size);
; [51]         HeapPtr^.Size := R^.Size - Size;
; [52]         HeapPtr^.Next := R^.Next;
; [53]       end
; [54]       else
; [55]       begin
; [56]         Q^.Next := Ptr(Ord(R) + Size);
; [57]         Q^.Next^.Size := R^.Size - Size;
; [58]         Q^.Next^.Next := R^.Next;
; [59]       end;
; [60] 
; [61]       P := R;
; [62] 
; [63]       Exit;
; [64]     end;
; [65] 
; [66]     Q := R;
; [67]     R := R^.Next;
; [68]   end;
; [69] 
; [70]   WriteLn('Out of memory error');
; [71]   while True do;
; [72] end;
; [73] *)
; [74] procedure InitHeap(Bytes: Integer);
; 
; [75] var
; [76]   P: Pointer;
; [77] begin
; var Bytes(+6), P(-2)
; 
proc2:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [78]   HeapPtr := nil;
                ld      hl,__heapptr    ; Get global HeapPtr
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [79]   P := Ptr(32768); (* GetHeapStart; *)
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,32768        ; Literal 32768
                pop     hl
                ld      (hl),de
; [80]   FreeMem(P, Bytes);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __freemem
; [81] end;
exit3:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [82] 
; [83] function MemAvail: Integer;
; 
; [84] var
; [85]   P: PBlock;
; [86]   I: Integer;
; [87] begin
; var MemAvail(+6), P(-2), I(-4)
; 
func4:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-4
                add     hl,sp
                ld      sp,hl
; [88]   P := HeapPtr;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,__heapptr    ; Get global HeapPtr
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [89]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [90]   while P <> nil do
while6:
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [91]   begin
                pop     hl
                bit     0,l
                jp      z,false7
; [92]     I := I + P^.Size;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [93]     P := P^.Next;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [94]   end;
                jp      while6
false7:
; [95] 
; [96]   MemAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [97] end;
exit5:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [98] 
; [99] function MaxAvail: Integer;
; 
; [100] var
; [101]   P: PBlock;
; [102]   I: Integer;
; [103] begin
; var MaxAvail(+6), P(-2), I(-4)
; 
func8:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-4
                add     hl,sp
                ld      sp,hl
; [104]   P := HeapPtr;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,__heapptr    ; Get global HeapPtr
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [105]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [106]   while P <> nil do
while10:
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [107]   begin
                pop     hl
                bit     0,l
                jp      z,false11
; [108]     if P^.Size > I then I := P^.Size;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false12
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
false12:
; [109]     P := P^.Next;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [110]   end;
                jp      while10
false11:
; [111] 
; [112]   MaxAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [113] end;
exit9:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [114] 
; [115] type
; 
; [116]   TString = String[255];
; [117] 
; [118] function Random(Range: Integer): Integer; register; external '__random';
; [119] 
; [120] function Length(S: TString): Integer; stdcall; external '__length';
; 
; [121] function Concat(S, T: TString): TString; stdcall; external '__concat';
; 
; [122] function Pos(S, T: TString): Integer; stdcall; external '__pos';
; 
; [123] function Copy(S: TString; Start: Integer; Count: Integer): TString; stdcall; external '__copy';
; 
; [124] procedure Insert(S: TString; var T: TString; Start: Integer); stdcall; external '__insert';
; 
; [125] procedure Delete(var S: TString; Start: Integer; Count: Integer); stdcall; external '__delete';
; 
; [126] 
; [127] procedure Val(S: TString; var I, Code: Integer); stdcall; external '__val_int';
; 
; [128] {
; [129] procedure Str(I: Integer; var S: TString); stdcall; external '__str_int';
; [130] }
; [131] 
; [132] procedure ClrScr; register; external '__clrscr';
; 
; [133] procedure GotoXY(X, Y: Integer); register; external '__gotoxy';
; 
; [134] procedure TextColor(I: Integer); register; external '__textfg';
; 
; [135] procedure TextBackground(I: Integer); register; external '__textbg';
; 
; [136] procedure CursorOn; register; external '__cursor_on';
; 
; [137] procedure CursorOff; register; external '__cursor_off';
; 
; [138] 
; [139] (* Arithmetic functions *)
; [140] 
; [141] (* function Abs(I: Integer): Integer  *) (* built-in *)
; [142] (* function Abs(R: Real): Real        *) (* built-in *)
; [143] function ArcTan(R: Real): Real; register; external 'ATN';
; 
; [144] function Cos(R: Real): Real; register; external 'COS';
; 
; [145] function Exp(R: Real): Real; register; external 'EXP';
; 
; [146] function Frac(R: Real): Real; register; external 'FRAC';
; 
; [147] function Int(R: Real): Real; register; external 'INT';
; 
; [148] function Ln(R: Real): Real; register; external 'LN';
; 
; [149] function Log(R: Real): Real; register; external 'LOG';
; 
; [150] function Pi: Real; register; external 'ACPI';
; 
; [151] function Sin(R: Real): Real; register; external 'SIN';
; 
; [152] function Sqr(R: Real): Real; register; external '__fltpwr2';
; 
; [153] function Sqrt(R: Real): Real; register; external 'SQR';
; 
; [154] function Tan(R: Real): Real; register; external 'TAN';
; 
; [155] 
; [156] (* Scalar functions *
; [157] 
; [158] (* Pred, Succ, Odd *)
; [159] 
; [160] (* Transfer functions *)
; [161] 
; [162] (* Chr, Ord, Round, Trunc *)
; [163] 
; [164] (* Miscellaneous functions *)
; [165] 
; [166] (* 
; [167]   Hi ld l,h, ld h,0
; [168]   KeyPressed
; [169]   Lo ld h,0
; [170]   Random
; [171]   Random(I)
; [172]   ParamCount
; [173]   ParamStr
; [174]   SizeOf ok
; [175]   Swap ld a,h, ld h,l, ld l,a
; [176]   UpCase  -> lib z80
; [177] *)
; [0] program Supply;
; 
; [1] 
; [2] {$I /Users/joerg/Projekte/pl0/lib/files.pas}
; [0] type
; [1]   FileControlBlock = record
; [2]     DR: Byte;
; [3]     FN: array[0..7] of Char;
; [4]     TN: array[0..2] of Char;
; [5]     EX, S1, S2, RC: Byte;
; [6]     AL: array[0..15] of Byte;
; [7]     CR: Byte;
; [8]     RN: array[0..2] of Byte;
; [9]   end;
; [10] 
; [11]   Text = record
; [12]     Offset: Integer;
; [13]     Writing: Boolean;
; [14]     FCB: FileControlBlock;
; [15]     DMA: array[0..127] of Char;
; [16]   end;
; [17] 
; [18] procedure Assign(var T: Text; S: TString);
; [19] var
; [20]   I: Integer;
; [21] begin
; var T(+262), S(+6), I(-2)
; 
proc39:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [22]   T.FCB.DR := 0;
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [23] 
; [24]   for I := 1 to 8 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                ld      de,8            ; Literal 8
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak42
forloop41:
; [25]     T.FCB.FN[I - 1] := S[I];
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
fornext43:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak42
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop41
forbreak42:     pop     de              ; Cleanup limit
; [26] 
; [27]   for I := 10 to 12 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,10           ; Literal 10
                pop     hl
                ld      (hl),de
                ld      de,12           ; Literal 12
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak45
forloop44:
; [28]     T.FCB.TN[I - 10] := S[I];
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,9            ; Literal 9
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,10           ; Literal 10
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
fornext46:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak45
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop44
forbreak45:     pop     de              ; Cleanup limit
; [29] end;
exit40:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [30] 
; [31] procedure Reset(var T: Text);
; 
; [32] var
; [33]   A: Integer;
; [34] begin
; var T(+6), A(-2)
; 
proc47:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [35]   T.FCB.EX := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,12           ; Literal 12
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [36]   T.FCB.S1 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,13           ; Literal 13
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [37]   T.FCB.S2 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,14           ; Literal 14
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [38]   T.FCB.RC := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,15           ; Literal 15
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [39]   T.FCB.CR := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,32           ; Literal 32
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [40] 
; [41]   T.Writing := False;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [42] 
; [43]   A := Bdos(15, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,15           ; Literal 15
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [44] 
; [45]   T.Offset := 128;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,128          ; Literal 128
                pop     hl
                ld      (hl),de
; [46] end;
exit48:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [47] 
; [48] procedure Rewrite(var T: Text);
; 
; [49] var
; [50]   A: Integer;
; [51] begin
; var T(+6), A(-2)
; 
proc49:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [52]   T.FCB.EX := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,12           ; Literal 12
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [53]   T.FCB.S1 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,13           ; Literal 13
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [54]   T.FCB.S2 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,14           ; Literal 14
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [55]   T.FCB.RC := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,15           ; Literal 15
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [56]   T.FCB.CR := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,32           ; Literal 32
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [57] 
; [58]   T.Writing := True;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),e
; [59] 
; [60]   A := Bdos(19, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [61]   A := Bdos(22, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,22           ; Literal 22
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [62] 
; [63]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [64] end;
exit50:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [65] 
; [66] procedure ReadRec(var T: Text);
; 
; [67] var
; [68]   A: Integer;
; [69] begin
; var T(+6), A(-2)
; 
proc51:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [70]   A := Bdos(26, Addr(T.DMA));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [71]   A := Bdos(20, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,20           ; Literal 20
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [72]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [73] end;
exit52:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [74] 
; [75] function ReadChar(var T: Text): Char;
; 
; [76] var
; [77]   C: Char;
; [78] begin
; var ReadChar(+8), T(+6), C(-2)
; 
func53:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [79]   if T.Offset > 127 then ReadRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,127          ; Literal 127
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false55
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc51
; Cleanup 2 bytes
                pop     hl
false55:
; [80]   C := T.DMA[T.Offset];
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [81]   if C <> #26 then T.Offset := T.Offset + 1;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,26           ; Literal 26
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false56
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
false56:
; [82]   ReadChar := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [83] end;
exit54:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [84] 
; [85] procedure ReadLine(var T: Text; var S: TString);
; 
; [86] var
; [87]   C: Char;
; [88] begin
; var T(+8), S(+6), C(-2)
; 
proc57:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [89]   S := '';
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,string59
                pop     de
                ld      a,255
                call    __movestr
; [90] 
; [91]   while Length(S) < 255 do
while60:
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [92]   begin
                pop     hl
                bit     0,l
                jp      z,false61
; [93]     C := ReadChar(T);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    func53
; Cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),e
; [94] 
; [95]     if C = #10 then Break;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,10           ; Literal 10
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false62
                jp      false61         ; Break
false62:
; [96]     if C = #26 then Break;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,26           ; Literal 26
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false63
                jp      false61         ; Break
false63:
; [97] 
; [98]     if C >= ' ' then S := S + C;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,32           ; Literal 32
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false64
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      d,e
                ld      e,1
                push    de
                call    __stradd
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
false64:
; [99]   end;
                jp      while60
false61:
; [100] end;
exit58:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [101] 
; [102] procedure WriteRec(var T: Text);
; 
; [103] var
; [104]   A: Integer;
; [105] begin
; var T(+6), A(-2)
; 
proc65:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [106]   A := Bdos(26, Addr(T.DMA));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [107]   A := Bdos(21, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,21           ; Literal 21
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [108]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [109] end;
exit66:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [110] 
; [111] 
; [112] procedure WriteChar(var T: Text; C: Char);
; 
; [113] begin
; var T(+8), C(+6)
; 
proc67:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,0
                add     hl,sp
                ld      sp,hl
; [114]   if T.Offset > 127 then WriteRec(T);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,127          ; Literal 127
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false69
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc65
; Cleanup 2 bytes
                pop     hl
false69:
; [115]   T.DMA[T.Offset] := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [116]   T.Offset := T.Offset + 1;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [117] end;
exit68:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [118] 
; [119] procedure WriteLine(var T: Text; S: TString);
; 
; [120] var
; [121]   I: Integer;
; [122] begin
; var T(+262), S(+6), I(-2)
; 
proc70:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [123]   for I := 1 to Length(S) do WriteChar(T, S[I]);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak73
forloop72:
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                call    proc67
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
fornext74:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak73
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop72
forbreak73:     pop     de              ; Cleanup limit
; [124] 
; [125]   WriteChar(T, #13);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,13           ; Literal 13
                push    de
                call    proc67
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [126]   WriteChar(T, #10);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,10           ; Literal 10
                push    de
                call    proc67
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [127] end;
exit71:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [128] 
; [129] function IsEof(var T: Text): Boolean;
; 
; [130] begin
; var IsEof(+8), T(+6)
; 
func75:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,0
                add     hl,sp
                ld      sp,hl
; [131]   if T.Offset > 127 then ReadRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,127          ; Literal 127
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false77
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc51
; Cleanup 2 bytes
                pop     hl
false77:
; [132]   IsEof := T.DMA[T.Offset] = #26;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,26           ; Literal 26
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ld      de,hl
                pop     hl
                ld      (hl),e
; [133] end;        
exit76:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [134] 
; [135] procedure Close(var T: Text);
; 
; [136] var
; [137]   A: Integer;
; [138] begin
; var T(+6), A(-2)
; 
proc78:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [139]   if T.Writing then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
; [140]   begin
                pop     hl
                bit     0,l
                jp      z,false80
; [141]     WriteChar(T, #26);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,26           ; Literal 26
                push    de
                call    proc67
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [142]     WriteRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc65
; Cleanup 2 bytes
                pop     hl
; [143]   end;
false80:
; [144] 
; [145]   A := Bdos(16, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,16           ; Literal 16
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [146] end;
exit79:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [3] 
; [4] var
; 
; [5]   Stacks: array[0..9] of String[64];
global81:       ds      650             ; Global Stacks
; [6] 
; [7] procedure Dump(I: Integer);
; [8] var
; [9]   L: Integer;
; [10] begin
; var I(+6), L(-2)
; 
proc82:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [11]   L := Length(Stacks[I]);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                push    hl
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [12]   GotoXY(1, 4 + I);
                ld      de,1            ; Literal 1
                push    de
                ld      de,4            ; Literal 4
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                call    __gotoxy
; [13]   Write(I, ': ');
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __putn
                ld      hl,string84
                call    __puts
; [14]   if L > 1 then
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [15]     Write(Copy(Stacks[I], 1, L - 1));
                pop     hl
                bit     0,l
                jp      z,false85
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                call    __loadstr
                ld      de,1            ; Literal 1
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                call    __copy
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                ld      hl,0
                add     hl,sp
                call    __puts
                ld      hl,256
                add     hl,sp
                ld      sp,hl
false85:
; [16] 
; [17]   if L > 0 then
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [18]   begin
                pop     hl
                bit     0,l
                jp      z,false86
; [19]     Write(#27'p');
                ld      hl,string87
                call    __puts
; [20]     Write(Stacks[I][L]);
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,de
                ld      a,l
                call    __putc
; [21]     Write(#27'q');
                ld      hl,string88
                call    __puts
; [22]   end;
false86:
; [23] 
; [24]   Write(#27'K');
                ld      hl,string89
                call    __puts
; [25] end;
exit83:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [26] 
; [27] procedure Push(I: Integer; C: Char);
; 
; [28] begin
; var I(+8), C(+6)
; 
proc90:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,0
                add     hl,sp
                ld      sp,hl
; [29]   Stacks[I] := Stacks[I] + C;
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      d,e
                ld      e,1
                push    de
                call    __stradd
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,64
                call    __storestr
; [30] end;
exit91:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [31] 
; [32] function Pop(I: Integer): Char;
; 
; [33] var
; [34]   L: Integer;
; [35] begin
; var Pop(+8), I(+6), L(-2)
; 
func92:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [36]   L := Length(Stacks[I]);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                push    hl
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [37]   Pop := Stacks[I][L];
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [38]   Stacks[I][0] := Char(L - 1);
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),e
; [39] end;
exit93:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [40] 
; [41] procedure Clear(I: Integer);
; 
; [42] begin
; var I(+6)
; 
proc94:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,0
                add     hl,sp
                ld      sp,hl
; [43]   Stacks[I][0] := #0;
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [44] end;
exit95:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [45] 
; [46] function IsEmpty(I: Integer): Boolean;
; 
; [47] begin
; var IsEmpty(+8), I(+6)
; 
func96:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,0
                add     hl,sp
                ld      sp,hl
; [48]   IsEmpty := Length(Stacks[I]) = 0;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                push    hl
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ld      de,hl
                pop     hl
                ld      (hl),e
; [49] end;
exit97:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [50] 
; [51] procedure Move1(Count, Source, Dest: Integer);
; 
; [52] var
; [53]   I: Integer;
; [54] begin
; var Count(+10), Source(+8), Dest(+6), I(-2)
; 
proc98:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [55]   for I := 1 to Count do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak101
forloop100:
; [56]   begin
; [57]     Push(Dest, Pop(Source));
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    func92
; Cleanup 2 bytes
                pop     hl
                call    proc90
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [58]     Dump(Source);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc82
; Cleanup 2 bytes
                pop     hl
; [59]     Dump(Dest);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc82
; Cleanup 2 bytes
                pop     hl
; [60]   end;
fornext102:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak101
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop100
forbreak101:    pop     de              ; Cleanup limit
; [61] end;
exit99:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [62] 
; [63] procedure Move2(Count, Source, Dest: Integer);
; 
; [64] var
; [65]   I: Integer;
; [66] begin
; var Count(+10), Source(+8), Dest(+6), I(-2)
; 
proc103:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [67]   for I := 1 to Count do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak106
forloop105:
; [68]   begin
; [69]     Push(0, Pop(Source));
                ld      de,0            ; Literal 0
                push    de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    func92
; Cleanup 2 bytes
                pop     hl
                call    proc90
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [70]     Dump(Source);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc82
; Cleanup 2 bytes
                pop     hl
; [71]   end;
fornext107:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak106
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop105
forbreak106:    pop     de              ; Cleanup limit
; [72] 
; [73]   for I := 1 to Count do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak109
forloop108:
; [74]   begin
; [75]     Push(Dest, Pop(0));
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                push    hl
                ld      de,0            ; Literal 0
                push    de
                call    func92
; Cleanup 2 bytes
                pop     hl
                call    proc90
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [76]     Dump(Dest);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc82
; Cleanup 2 bytes
                pop     hl
; [77]   end;
fornext110:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak109
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop108
forbreak109:    pop     de              ; Cleanup limit
; [78] end;
exit104:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [79] 
; [80] function Solve(Model: Integer): TString;
; 
; [81] var
; [82]   T: Text;
; [83]   S: TString;
; [84]   I, J, Count, Source, Dest, Err: Integer;
; [85]   C: Char;
; [86] begin
; var Solve(+8), Model(+6), T(-167), S(-423), I(-425), J(-427), Count(-429), Source(-431), Dest(-433), Err(-435), C(-437)
; 
func111:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-437
                add     hl,sp
                ld      sp,hl
; [87]   for I := 0 to 9 do
                ld      de,ix
                ld      hl,-425
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      de,9            ; Literal 9
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak114
forloop113:
; [88]     Clear(I);
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc94
; Cleanup 2 bytes
                pop     hl
fornext115:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak114
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop113
forbreak114:    pop     de              ; Cleanup limit
; [89] 
; [90]   Assign(T, 'INPUT   .TXT');
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      hl,string116
                call    __loadstr
                call    proc39
; Cleanup 2 bytes
                pop     hl
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; [91]   Reset(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc47
; Cleanup 2 bytes
                pop     hl
; [92] 
; [93]   ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc57
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [94]   while Pos('[', S) <> 0 do
while117:
                push    hl
                ld      de,91           ; Literal 91
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      d,e
                ld      e,1
                push    de
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                call    __pos
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [95]   begin
                pop     hl
                bit     0,l
                jp      z,false118
; [96]     for I := 1 to (Length(S) + 1) / 4 do
                ld      de,ix
                ld      hl,-425
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                pop     hl
                call    __sdiv16        ; Div
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak120
forloop119:
; [97]     begin
; [98]       C := S[4 * I - 2];
                ld      de,ix
                ld      hl,-437
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __mul16         ; Mul
                push    hl
                ld      de,2            ; Literal 2
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [99]       if C <> ' ' then Insert(C, Stacks[I], 1);
                ld      de,ix
                ld      hl,-437
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,32           ; Literal 32
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false122
                ld      de,ix
                ld      hl,-437
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      d,e
                ld      e,1
                push    de
                ld      hl,global81     ; Get global Stacks
                push    hl
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,65           ; Literal 65
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                call    __insert
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
false122:
; [100]     end;
fornext121:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak120
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop119
forbreak120:    pop     de              ; Cleanup limit
; [101]     
; [102]     ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc57
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [103]   end;
                jp      while117
false118:
; [104] 
; [105]   for I := 1 to 9 do
                ld      de,ix
                ld      hl,-425
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                ld      de,9            ; Literal 9
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak124
forloop123:
; [106]     Dump(I);
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc82
; Cleanup 2 bytes
                pop     hl
fornext125:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak124
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop123
forbreak124:    pop     de              ; Cleanup limit
; [107] 
; [108]   ReadLine(T, S); { Empty line }
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc57
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [109]   while not IsEof(T) do
while126:
                push    hl
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    func75
; Cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
                push    hl
; [110]   begin
                pop     hl
                bit     0,l
                jp      z,false127
; [111]     ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc57
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [112] 
; [113]     I := Pos(' from ', S);
                ld      de,ix
                ld      hl,-425
                add     hl,de
                push    hl
                push    hl
                ld      hl,string128
                call    __loadstr
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                call    __pos
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [114]     J := Pos(' to ', S);
                ld      de,ix
                ld      hl,-427
                add     hl,de
                push    hl
                push    hl
                ld      hl,string129
                call    __loadstr
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                call    __pos
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [115] 
; [116]     Val(Copy(S, 6, I - 6), Count, Err);
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      de,6            ; Literal 6
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,6            ; Literal 6
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                call    __copy
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                ld      de,ix
                ld      hl,-429
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-435
                add     hl,de
                push    hl
                call    __val_int
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [117]     Val(Copy(S, I + 6, J - I + 6), Source, Err);
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,6            ; Literal 6
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-427
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                ld      de,6            ; Literal 6
                pop     hl
                add     hl,de
                push    hl
                call    __copy
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                ld      de,ix
                ld      hl,-431
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-435
                add     hl,de
                push    hl
                call    __val_int
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [118]     Val(Copy(S, J + 4, 255), Dest, Err);
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,-427
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,4            ; Literal 4
                pop     hl
                add     hl,de
                push    hl
                ld      de,255          ; Literal 255
                push    de
                call    __copy
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                ld      de,ix
                ld      hl,-433
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-435
                add     hl,de
                push    hl
                call    __val_int
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [119] 
; [120]     GotoXY(1, 3);
                ld      de,1            ; Literal 1
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                call    __gotoxy
; [121]     WriteLn('CrateMover (tm) '#27'p' , Model, #27'q now moving ', Count:2, ' creates from ', Source, ' to ', Dest);
                ld      hl,string130
                call    __puts
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __putn
                ld      hl,string131
                call    __puts
                ld      de,ix
                ld      hl,-429
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                ld      bc,de
                pop     hl
                call    __putn_fmt
                ld      hl,string132
                call    __puts
                ld      de,ix
                ld      hl,-431
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __putn
                ld      hl,string129
                call    __puts
                ld      de,ix
                ld      hl,-433
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __putn
                call    __newline
; [122] 
; [123]     if Model = 9000 then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,9000         ; Literal 9000
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                push    hl
; [124]       Move1(Count, Source, Dest)
                pop     hl
                bit     0,l
                jp      z,false133
                ld      de,ix
                ld      hl,-429
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-431
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-433
                add     hl,de
                ld      de,(hl)
                push    de
; [125]     else
                call    proc98
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                jp      endif134
false133:
; [126]       Move2(Count, Source, Dest);
                ld      de,ix
                ld      hl,-429
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-431
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-433
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc103
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
endif134:
; [127]   end;
                jp      while126
false127:
; [128] 
; [129]   Close(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc78
; Cleanup 2 bytes
                pop     hl
; [130] 
; [131]   S := '';
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                ld      hl,string59
                pop     de
                ld      a,255
                call    __movestr
; [132]   for I := 0 to 9 do
                ld      de,ix
                ld      hl,-425
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      de,9            ; Literal 9
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak136
forloop135:
; [133]     if not IsEmpty(I) then S := S + Pop(I);
                push    hl
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                call    func96
; Cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
                bit     0,l
                jp      z,false138
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                push    hl
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                call    func92
; Cleanup 2 bytes
                pop     hl
                pop     de
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      d,e
                ld      e,1
                push    de
                call    __stradd
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
false138:
fornext137:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak136
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop135
forbreak136:    pop     de              ; Cleanup limit
; [134] 
; [135]   Solve := S;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                pop     de
                ld      a,255
                call    __movestr
; [136] end;
exit112:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [137] 
; [138] var
; 
; [139]   S: TString;
global139:      ds      256             ; Global S
; [140] 
; [141] begin
; var Mem(0), HeapPtr(0), AssertPassed(0), AssertFailed(0), Stacks(0), S(0)
; 
main:           call    __init
                ld      ix,0
                add     ix,sp
; [142]   ClrScr;
                call    __clrscr
; [143] 
; [144]   Write(#27'f');
                ld      hl,string141
                call    __puts
; [145]   WriteLn('*** AoC 2022.05 Supply Stacks ***');
                ld      hl,string142
                call    __puts
                call    __newline
; [146]   WriteLn;
                call    __newline
; [147] 
; [148]   S := Solve(9000);
                ld      hl,global139    ; Get global S
                push    hl
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,9000         ; Literal 9000
                push    de
                call    func111
; Cleanup 2 bytes
                pop     hl
                ld      a,255
                call    __storestr
; [149]   GotoXY(1, 15);
                ld      de,1            ; Literal 1
                push    de
                ld      de,15           ; Literal 15
                pop     hl
                call    __gotoxy
; [150]   WriteLn('Part 1: ', S);
                ld      hl,string143
                call    __puts
                ld      hl,global139    ; Get global S
                call    __puts
                call    __newline
; [151] 
; [152]   S := Solve(9001);
                ld      hl,global139    ; Get global S
                push    hl
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,9001         ; Literal 9001
                push    de
                call    func111
; Cleanup 2 bytes
                pop     hl
                ld      a,255
                call    __storestr
; [153]   GotoXY(1, 16);
                ld      de,1            ; Literal 1
                push    de
                ld      de,16           ; Literal 16
                pop     hl
                call    __gotoxy
; [154]   WriteLn('Part 2: ', S);
                ld      hl,string144
                call    __puts
                ld      hl,global139    ; Get global S
                call    __puts
                call    __newline
; [155]   Write(#27'e');
                ld      hl,string145
                call    __puts
; [156] end.
exit140:        call    __done
                ret
; 
string59:       db      0
; 
string84:       db      2,": "
; 
string87:       db      2,27,"p"
; 
string88:       db      2,27,"q"
; 
string89:       db      2,27,"K"
; 
string116:      db      12,"INPUT   .TXT"
; 
string128:      db      6," from "
; 
string129:      db      4," to "
; 
string130:      db      18,"CrateMover (tm) ",27,"p"
; 
string131:      db      14,27,"q now moving "
; 
string132:      db      14," creates from "
; 
string141:      db      2,27,"f"
; 
string142:      db      33,"*** AoC 2022.05 Supply Stacks ***"
; 
string143:      db      8,"Part 1: "
; 
string144:      db      8,"Part 2: "
; 
string145:      db      2,27,"e"
; 
display:        ds      32              ; Display
; 
eof:                                    ; End of file
; 
; HEAP:
; 
; end
; 
