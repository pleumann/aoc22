; 
; program treetop2.pas
; 
CPM:            equ     1               ; Target is CP/M .com file
; 
                include "/Users/joerg/Projekte/pl0/pl0.z80"
; 
                jp      main
; 
; [0] (* Built-ins that do not have to be defined in the compiler itself. *)
; [1] 
; [2] type
; [3]   PBlock = ^TBlock;
; [4]   TBlock = record
; [5]     Next: PBlock;
; [6]     Size: Integer;
; [7]   end;
; [8] 
; [9] var
; [10]   HeapPtr: PBlock absolute '__heapptr';
; [11] 
; [12]   AssertPassed: Integer absolute '__assertpassed';
; [13]   AssertFailed: Integer absolute '__assertfailed';
; [14] 
; [15] procedure FreeMem(P: Pointer; Size: Integer); register; external '__freemem';
; [16] (*var
; [17]   Q: PBlock;
; [18] begin
; [19]   Q := P;
; [20]   Q^.Size := Size;
; [21]   Q^.Next := HeapPtr;
; [22]   HeapPtr := Q;
; [23]   P := nil;
; [24] end;
; [25] *)
; [26] 
; [27] procedure GetMem(var P: Pointer; Size: Integer); register; external '__getmem';
; 
; [28] (*var
; [29]   Q, R: PBlock;
; [30] begin
; [31]   Q := nil;
; [32]   R := HeapPtr;
; [33]   while R <> nil do
; [34]   begin
; [35]     if R^.Size = Size then
; [36]     begin
; [37]       if Q = nil then
; [38]         HeapPtr := R^.Next
; [39]       else
; [40]         Q^.Next := R^.Next;
; [41] 
; [42]       P := R;
; [43] 
; [44]       Exit;
; [45]     end
; [46]     else if R^.Size >= Size + 4 then
; [47]     begin
; [48]       if Q = nil then
; [49]       begin
; [50]         HeapPtr := Ptr(Ord(R) + Size);
; [51]         HeapPtr^.Size := R^.Size - Size;
; [52]         HeapPtr^.Next := R^.Next;
; [53]       end
; [54]       else
; [55]       begin
; [56]         Q^.Next := Ptr(Ord(R) + Size);
; [57]         Q^.Next^.Size := R^.Size - Size;
; [58]         Q^.Next^.Next := R^.Next;
; [59]       end;
; [60] 
; [61]       P := R;
; [62] 
; [63]       Exit;
; [64]     end;
; [65] 
; [66]     Q := R;
; [67]     R := R^.Next;
; [68]   end;
; [69] 
; [70]   WriteLn('Out of memory error');
; [71]   while True do;
; [72] end;
; [73] *)
; [74] procedure InitHeap(Bytes: Integer);
; 
; [75] var
; [76]   P: Pointer;
; [77] begin
; var Bytes(+6), P(-2)
; 
proc2:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [78]   HeapPtr := nil;
                ld      hl,__heapptr    ; Get global HeapPtr
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [79]   P := Ptr(32768); (* GetHeapStart; *)
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,32768        ; Literal 32768
                pop     hl
                ld      (hl),de
; [80]   FreeMem(P, Bytes);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __freemem
; [81] end;
exit3:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [82] 
; [83] function MemAvail: Integer;
; 
; [84] var
; [85]   P: PBlock;
; [86]   I: Integer;
; [87] begin
; var MemAvail(+6), P(-2), I(-4)
; 
func4:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-4
                add     hl,sp
                ld      sp,hl
; [88]   P := HeapPtr;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,__heapptr    ; Get global HeapPtr
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [89]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [90]   while P <> nil do
while6:
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [91]   begin
                pop     hl
                bit     0,l
                jp      z,false7
; [92]     I := I + P^.Size;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [93]     P := P^.Next;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [94]   end;
                jp      while6
false7:
; [95] 
; [96]   MemAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [97] end;
exit5:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [98] 
; [99] function MaxAvail: Integer;
; 
; [100] var
; [101]   P: PBlock;
; [102]   I: Integer;
; [103] begin
; var MaxAvail(+6), P(-2), I(-4)
; 
func8:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-4
                add     hl,sp
                ld      sp,hl
; [104]   P := HeapPtr;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,__heapptr    ; Get global HeapPtr
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [105]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [106]   while P <> nil do
while10:
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [107]   begin
                pop     hl
                bit     0,l
                jp      z,false11
; [108]     if P^.Size > I then I := P^.Size;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false12
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
false12:
; [109]     P := P^.Next;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [110]   end;
                jp      while10
false11:
; [111] 
; [112]   MaxAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [113] end;
exit9:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [114] 
; [115] type
; 
; [116]   TString = String[255];
; [117] 
; [118] function Random(Range: Integer): Integer; register; external '__random';
; [119] 
; [120] function Length(S: TString): Integer; stdcall; external '__length';
; 
; [121] function Concat(S, T: TString): TString; stdcall; external '__concat';
; 
; [122] function Pos(S, T: TString): Integer; stdcall; external '__pos';
; 
; [123] function Copy(S: TString; Start: Integer; Count: Integer): TString; stdcall; external '__copy';
; 
; [124] procedure Insert(S: TString; var T: TString; Start: Integer); stdcall; external '__insert';
; 
; [125] procedure Delete(var S: TString; Start: Integer; Count: Integer); stdcall; external '__delete';
; 
; [126] 
; [127] {
; [128]   procedure Val(S: TString; var I, Code: Integer); stdcall; external '__val_int';
; [129] procedure Str(I: Integer; var S: TString); stdcall; external '__str_int';
; [130] }
; [131] 
; [132] procedure ClrScr; register; external '__clrscr';
; 
; [133] procedure GotoXY(X, Y: Integer); register; external '__gotoxy';
; 
; [134] procedure TextColor(I: Integer); register; external '__textfg';
; 
; [135] procedure TextBackground(I: Integer); register; external '__textbg';
; 
; [136] procedure CursorOn; register; external '__cursor_on';
; 
; [137] procedure CursorOff; register; external '__cursor_off';
; 
; [138] 
; [139] (* Arithmetic functions *)
; [140] 
; [141] (* function Abs(I: Integer): Integer  *) (* built-in *)
; [142] (* function Abs(R: Real): Real        *) (* built-in *)
; [143] function ArcTan(R: Real): Real; register; external 'ATN';
; 
; [144] function Cos(R: Real): Real; register; external 'COS';
; 
; [145] function Exp(R: Real): Real; register; external 'EXP';
; 
; [146] function Frac(R: Real): Real; register; external 'FRAC';
; 
; [147] function Int(R: Real): Real; register; external 'INT';
; 
; [148] function Ln(R: Real): Real; register; external 'LN';
; 
; [149] function Log(R: Real): Real; register; external 'LOG';
; 
; [150] function Pi: Real; register; external 'ACPI';
; 
; [151] function Sin(R: Real): Real; register; external 'SIN';
; 
; [152] function Sqr(R: Real): Real; register; external '__fltpwr2';
; 
; [153] function Sqrt(R: Real): Real; register; external 'SQR';
; 
; [154] function Tan(R: Real): Real; register; external 'TAN';
; 
; [155] 
; [156] (* Scalar functions *
; [157] 
; [158] (* Pred, Succ, Odd *)
; [159] 
; [160] (* Transfer functions *)
; [161] 
; [162] (* Chr, Ord, Round, Trunc *)
; [163] 
; [164] (* Miscellaneous functions *)
; [165] 
; [166] (* 
; [167]   Hi ld l,h, ld h,0
; [168]   KeyPressed
; [169]   Lo ld h,0
; [170]   Random
; [171]   Random(I)
; [172]   ParamCount
; [173]   ParamStr
; [174]   SizeOf ok
; [175]   Swap ld a,h, ld h,l, ld l,a
; [176]   UpCase  -> lib z80
; [177] *)
; [0] program TreeTop;
; 
; [1] 
; [2] {$I /Users/joerg/Projekte/pl0/lib/Files.pas}
; [0] type
; [1]   FileControlBlock = record
; [2]     DR: Byte;
; [3]     FN: array[0..7] of Char;
; [4]     TN: array[0..2] of Char;
; [5]     EX, S1, S2, RC: Byte;
; [6]     AL: array[0..15] of Byte;
; [7]     CR: Byte;
; [8]     RN: array[0..2] of Byte;
; [9]   end;
; [10] 
; [11]   Text = record
; [12]     Offset: Integer;
; [13]     Writing: Boolean;
; [14]     FCB: FileControlBlock;
; [15]     DMA: array[0..127] of Char;
; [16]   end;
; [17] 
; [18] procedure Assign(var T: Text; S: TString);
; [19] var
; [20]   I: Integer;
; [21] begin
; var T(+262), S(+6), I(-2)
; 
proc38:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [22]   T.FCB.DR := 0;
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [23] 
; [24]   for I := 1 to 8 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                ld      de,8            ; Literal 8
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak41
forloop40:
; [25]     T.FCB.FN[I - 1] := S[I];
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
fornext42:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak41
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop40
forbreak41:     pop     de              ; Cleanup limit
; [26] 
; [27]   for I := 10 to 12 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,10           ; Literal 10
                pop     hl
                ld      (hl),de
                ld      de,12           ; Literal 12
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak44
forloop43:
; [28]     T.FCB.TN[I - 10] := S[I];
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,9            ; Literal 9
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,10           ; Literal 10
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
fornext45:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak44
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop43
forbreak44:     pop     de              ; Cleanup limit
; [29] end;
exit39:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [30] 
; [31] procedure Reset(var T: Text);
; 
; [32] var
; [33]   A: Integer;
; [34] begin
; var T(+6), A(-2)
; 
proc46:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [35]   T.FCB.EX := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,12           ; Literal 12
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [36]   T.FCB.S1 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,13           ; Literal 13
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [37]   T.FCB.S2 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,14           ; Literal 14
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [38]   T.FCB.RC := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,15           ; Literal 15
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [39]   T.FCB.CR := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,32           ; Literal 32
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [40] 
; [41]   T.Writing := False;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [42] 
; [43]   A := Bdos(15, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,15           ; Literal 15
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [44] 
; [45]   T.Offset := 128;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,128          ; Literal 128
                pop     hl
                ld      (hl),de
; [46] end;
exit47:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [47] 
; [48] procedure Rewrite(var T: Text);
; 
; [49] var
; [50]   A: Integer;
; [51] begin
; var T(+6), A(-2)
; 
proc48:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [52]   T.FCB.EX := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,12           ; Literal 12
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [53]   T.FCB.S1 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,13           ; Literal 13
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [54]   T.FCB.S2 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,14           ; Literal 14
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [55]   T.FCB.RC := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,15           ; Literal 15
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [56]   T.FCB.CR := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,32           ; Literal 32
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [57] 
; [58]   T.Writing := True;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),e
; [59] 
; [60]   A := Bdos(19, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [61]   A := Bdos(22, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,22           ; Literal 22
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [62] 
; [63]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [64] end;
exit49:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [65] 
; [66] procedure ReadRec(var T: Text);
; 
; [67] var
; [68]   A: Integer;
; [69] begin
; var T(+6), A(-2)
; 
proc50:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [70]   A := Bdos(26, Addr(T.DMA));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [71]   A := Bdos(20, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,20           ; Literal 20
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [72]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [73] end;
exit51:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [74] 
; [75] function ReadChar(var T: Text): Char;
; 
; [76] var
; [77]   C: Char;
; [78] begin
; var ReadChar(+8), T(+6), C(-2)
; 
func52:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [79]   if T.Offset > 127 then ReadRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,127          ; Literal 127
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false54
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc50
; Cleanup 2 bytes
                pop     hl
false54:
; [80]   C := T.DMA[T.Offset];
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [81]   if C <> #26 then T.Offset := T.Offset + 1;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,26           ; Literal 26
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false55
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
false55:
; [82]   ReadChar := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [83] end;
exit53:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [84] 
; [85] procedure ReadLine(var T: Text; var S: TString);
; 
; [86] var
; [87]   C: Char;
; [88] begin
; var T(+8), S(+6), C(-2)
; 
proc56:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [89]   S := '';
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,string58
                pop     de
                ld      a,255
                call    __movestr
; [90] 
; [91]   while Length(S) < 255 do
while59:
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [92]   begin
                pop     hl
                bit     0,l
                jp      z,false60
; [93]     C := ReadChar(T);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    func52
; Cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),e
; [94] 
; [95]     if C = #10 then Break;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,10           ; Literal 10
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false61
                jp      false60         ; Break
false61:
; [96]     if C = #26 then Break;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,26           ; Literal 26
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false62
                jp      false60         ; Break
false62:
; [97] 
; [98]     if C >= ' ' then S := S + C;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,32           ; Literal 32
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false63
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      d,e
                ld      e,1
                push    de
                call    __stradd
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
false63:
; [99]   end;
                jp      while59
false60:
; [100] end;
exit57:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [101] 
; [102] procedure WriteRec(var T: Text);
; 
; [103] var
; [104]   A: Integer;
; [105] begin
; var T(+6), A(-2)
; 
proc64:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [106]   A := Bdos(26, Addr(T.DMA));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [107]   A := Bdos(21, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,21           ; Literal 21
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [108]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [109] end;
exit65:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [110] 
; [111] 
; [112] procedure WriteChar(var T: Text; C: Char);
; 
; [113] begin
; var T(+8), C(+6)
; 
proc66:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,0
                add     hl,sp
                ld      sp,hl
; [114]   if T.Offset > 127 then WriteRec(T);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,127          ; Literal 127
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false68
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc64
; Cleanup 2 bytes
                pop     hl
false68:
; [115]   T.DMA[T.Offset] := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [116]   T.Offset := T.Offset + 1;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [117] end;
exit67:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [118] 
; [119] procedure WriteLine(var T: Text; S: TString);
; 
; [120] var
; [121]   I: Integer;
; [122] begin
; var T(+262), S(+6), I(-2)
; 
proc69:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [123]   for I := 1 to Length(S) do WriteChar(T, S[I]);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak72
forloop71:
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                call    proc66
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
fornext73:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak72
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop71
forbreak72:     pop     de              ; Cleanup limit
; [124] 
; [125]   WriteChar(T, #13);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,13           ; Literal 13
                push    de
                call    proc66
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [126]   WriteChar(T, #10);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,10           ; Literal 10
                push    de
                call    proc66
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [127] end;
exit70:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [128] 
; [129] function IsEof(var T: Text): Boolean;
; 
; [130] begin
; var IsEof(+8), T(+6)
; 
func74:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,0
                add     hl,sp
                ld      sp,hl
; [131]   if T.Offset > 127 then ReadRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,127          ; Literal 127
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false76
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc50
; Cleanup 2 bytes
                pop     hl
false76:
; [132]   IsEof := T.DMA[T.Offset] = #26;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,26           ; Literal 26
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ld      de,hl
                pop     hl
                ld      (hl),e
; [133] end;        
exit75:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [134] 
; [135] procedure Close(var T: Text);
; 
; [136] var
; [137]   A: Integer;
; [138] begin
; var T(+6), A(-2)
; 
proc77:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [139]   if T.Writing then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
; [140]   begin
                pop     hl
                bit     0,l
                jp      z,false79
; [141]     WriteChar(T, #26);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,26           ; Literal 26
                push    de
                call    proc66
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [142]     WriteRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc64
; Cleanup 2 bytes
                pop     hl
; [143]   end;
false79:
; [144] 
; [145]   A := Bdos(16, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,16           ; Literal 16
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [146] end;
exit78:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [3] 
; [4] var
; 
; [5]   Map: array[0..99] of array[0..99] of Byte;
global80:       ds      10000           ; Global Map
; [6]   Visible: array[0..99] of array[0..99] of Boolean;
global81:       ds      10000           ; Global Visible
; [7]   Size, NumVisible: Integer;
global82:       ds      2               ; Global Size
global83:       ds      2               ; Global NumVisible
; [8] 
; [9] procedure Load;
; [10] var
; [11]   T: Text;
; [12]   S: TString;
; [13]   I, J: Integer;
; [14] begin
; var T(-167), S(-423), I(-425), J(-427)
; 
proc84:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-427
                add     hl,sp
                ld      sp,hl
; [15]   GotoXY(2, 3);
                ld      de,2            ; Literal 2
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                call    __gotoxy
; [16]   Write(#27'pInput file '#27'q');
                ld      hl,string86
                call    __puts
; [17] 
; [18]   Assign(T, 'INPUT   .TXT');
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      hl,string87
                call    __loadstr
                call    proc38
; Cleanup 2 bytes
                pop     hl
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; [19]   Reset(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc46
; Cleanup 2 bytes
                pop     hl
; [20] 
; [21]   ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc56
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [22]   Size := Length(S);
                ld      hl,global82     ; Get global Size
                push    hl
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [23] 
; [24]   for I := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-425
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak89
forloop88:
; [25]   begin
; [26]     GotoXY(2 + I mod 11, 4 + I / 11);
                ld      de,2            ; Literal 2
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Mod
                ex      hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Div
                ld      de,hl
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                call    __gotoxy
; [27]     Write('.');
                ld      de,46           ; Literal 46
                ld      hl,de
                ld      a,l
                call    __putc
; [28]     for J := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-427
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-427
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak92
forloop91:
; [29]     begin
; [30]       Map[I][J] := Ord(S[J + 1]) - 48;
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-427
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-427
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,48           ; Literal 48
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),e
; [31]       Visible[I][J] := False;
                ld      hl,global81     ; Get global Visible
                push    hl
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-427
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [32]     end;
fornext93:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-427
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak92
                ld      de,ix
                ld      hl,-427
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop91
forbreak92:     pop     de              ; Cleanup limit
; [33]     ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc56
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [34]   end;
fornext90:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak89
                ld      de,ix
                ld      hl,-425
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop88
forbreak89:     pop     de              ; Cleanup limit
; [35]         
; [36]   Close(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc77
; Cleanup 2 bytes
                pop     hl
; [37] 
; [38]   WriteLn;
                call    __newline
; [39]   WriteLn;
                call    __newline
; [40] end;
exit85:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [41] 
; [42] function CheckVisibility(Row, Column, Max: Integer): Integer;
; 
; [43] var
; [44]   K: Integer;
; [45] begin
; var CheckVisibility(+12), Row(+10), Column(+8), Max(+6), K(-2)
; 
func94:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [46]   K := Map[Row][Column];
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),de
; [47] 
; [48]   if K > Max then
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [49]   begin
                pop     hl
                bit     0,l
                jp      z,false96
; [50]     Max := K;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [51]     if not Visible[Row][Column] then
                ld      hl,global81     ; Get global Visible
                push    hl
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,de
                ld      a,1
                xor     l
                ld      l,a
                push    hl
; [52]     begin
                pop     hl
                bit     0,l
                jp      z,false97
; [53]       Visible[Row][Column] := True;
                ld      hl,global81     ; Get global Visible
                push    hl
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),e
; [54]       NumVisible := NumVisible + 1;
                ld      hl,global83     ; Get global NumVisible
                push    hl
                ld      hl,global83     ; Get global NumVisible
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [55]     end;
false97:
; [56]   end;
false96:
; [57] 
; [58]   CheckVisibility := Max;
                ld      de,ix
                ld      hl,12
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [59] end;
exit95:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [60] 
; [61] procedure Part1;
; 
; [62] var
; [63]   I, J, Max: Integer;
; [64] begin
; var I(-2), J(-4), Max(-6)
; 
proc98:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-6
                add     hl,sp
                ld      sp,hl
; [65]   NumVisible := 0;
                ld      hl,global83     ; Get global NumVisible
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [66] 
; [67]   GotoXY(15, 3);
                ld      de,15           ; Literal 15
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                call    __gotoxy
; [68]   Write(#27'pWest view  '#27'q');
                ld      hl,string100
                call    __puts
; [69] 
; [70]   for I := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak102
forloop101:
; [71]   begin
; [72]     GotoXY(15 + I mod 11, 4 + I / 11);
                ld      de,15           ; Literal 15
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Mod
                ex      hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Div
                ld      de,hl
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                call    __gotoxy
; [73]     Write('.');
                ld      de,46           ; Literal 46
                ld      hl,de
                ld      a,l
                call    __putc
; [74] 
; [75]     Max := -1;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                ld      hl,0
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [76]     for J := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak105
forloop104:
; [77]     begin
; [78]       Max := CheckVisibility(I, J, Max);
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                call    func94
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),de
; [79]       if Max = 9 then Break;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,9            ; Literal 9
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false107
                jp      forbreak105     ; Break
false107:
; [80]     end;
fornext106:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak105
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop104
forbreak105:    pop     de              ; Cleanup limit
; [81]   end;
fornext103:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak102
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop101
forbreak102:    pop     de              ; Cleanup limit
; [82] 
; [83]   GotoXY(28, 3);
                ld      de,28           ; Literal 28
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                call    __gotoxy
; [84]   Write(#27'pEast view  '#27'q');
                ld      hl,string108
                call    __puts
; [85] 
; [86]   for I := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak110
forloop109:
; [87]   begin
; [88]     GotoXY(28 + I mod 11, 4 + I / 11);
                ld      de,28           ; Literal 28
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Mod
                ex      hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Div
                ld      de,hl
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                call    __gotoxy
; [89]     Write('.');
                ld      de,46           ; Literal 46
                ld      hl,de
                ld      a,l
                call    __putc
; [90] 
; [91]     Max := -1;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                ld      hl,0
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [92]     for J := Size - 1 downto 0 do
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
                ld      de,0            ; Literal 0
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak113
forloop112:
; [93]     begin
; [94]       Max := CheckVisibility(I, J, Max);
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                call    func94
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),de
; [95]       if Max = 9 then Break;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,9            ; Literal 9
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false115
                jp      forbreak113     ; Break
false115:
; [96]     end;
fornext114:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak113
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                dec     de
                ld      (hl),de
                jp      forloop112
forbreak113:    pop     de              ; Cleanup limit
; [97]   end;
fornext111:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak110
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop109
forbreak110:    pop     de              ; Cleanup limit
; [98]         
; [99]   GotoXY(41, 3);
                ld      de,41           ; Literal 41
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                call    __gotoxy
; [100]   Write(#27'pNorth view '#27'q');
                ld      hl,string116
                call    __puts
; [101] 
; [102]   for J := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak118
forloop117:
; [103]   begin
; [104]     GotoXY(41 + J mod 11, 4 + J / 11);
                ld      de,41           ; Literal 41
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Mod
                ex      hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Div
                ld      de,hl
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                call    __gotoxy
; [105] 
; [106]     Write('.');
                ld      de,46           ; Literal 46
                ld      hl,de
                ld      a,l
                call    __putc
; [107] 
; [108]     Max := -1;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                ld      hl,0
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [109]     for I := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak121
forloop120:
; [110]     begin
; [111]       Max := CheckVisibility(I, J, Max);
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                call    func94
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),de
; [112]       if Max = 9 then Break;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,9            ; Literal 9
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false123
                jp      forbreak121     ; Break
false123:
; [113]     end;
fornext122:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak121
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop120
forbreak121:    pop     de              ; Cleanup limit
; [114]   end;
fornext119:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak118
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop117
forbreak118:    pop     de              ; Cleanup limit
; [115] 
; [116]   GotoXY(54, 3);
                ld      de,54           ; Literal 54
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                call    __gotoxy
; [117]   Write(#27'pSouth view '#27'q');
                ld      hl,string124
                call    __puts
; [118] 
; [119]   for J := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak126
forloop125:
; [120]   begin
; [121]     GotoXY(54 + J mod 11, 4 + J / 11);
                ld      de,54           ; Literal 54
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Mod
                ex      hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Div
                ld      de,hl
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                call    __gotoxy
; [122]     Write('.');
                ld      de,46           ; Literal 46
                ld      hl,de
                ld      a,l
                call    __putc
; [123] 
; [124]     Max := -1;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                ld      hl,0
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [125]     for I := Size - 1 downto 0 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
                ld      de,0            ; Literal 0
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak129
forloop128:
; [126]     begin
; [127]       Max := CheckVisibility(I, J, Max);
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                call    func94
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),de
; [128]       if Max = 9 then Break;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,9            ; Literal 9
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false131
                jp      forbreak129     ; Break
false131:
; [129]     end;
fornext130:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak129
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                dec     de
                ld      (hl),de
                jp      forloop128
forbreak129:    pop     de              ; Cleanup limit
; [130]   end;
fornext127:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak126
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop125
forbreak126:    pop     de              ; Cleanup limit
; [131] 
; [132]   GotoXY(1, 14);
                ld      de,1            ; Literal 1
                push    de
                ld      de,14           ; Literal 14
                pop     hl
                call    __gotoxy
; [133]   WriteLn('Part 1: ', NumVisible, ' visible trees');
                ld      hl,string132
                call    __puts
                ld      hl,global83     ; Get global NumVisible
                ld      de,(hl)
                ld      hl,de
                call    __putn
                ld      hl,string133
                call    __puts
                call    __newline
; [134] end;
exit99:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [135] 
; [136] function Score(Row, Column: Integer): Real;
; 
; [137] var
; [138]   K, Left, Right, Top, Bottom: Integer;
; [139]   Score1, Score2: Real;
; [140] begin
; var Score(+10), Row(+8), Column(+6), K(-2), Left(-4), Right(-6), Top(-8), Bottom(-10), Score1(-16), Score2(-22)
; 
func134:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-22
                add     hl,sp
                ld      sp,hl
; [141]   K := Map[Row][Column];
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),de
; [142] 
; [143]   Left := Column;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [144]   while Left > 0 do
while136:
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [145]   begin
                pop     hl
                bit     0,l
                jp      z,false137
; [146]     Left := Left - 1;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [147]     if Map[Row][Left] >= K then Break;
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false138
                jp      false137        ; Break
false138:
; [148]   end;
                jp      while136
false137:
; [149] 
; [150]   Right := Column;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [151]   while Right < Size - 1 do
while139:
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [152]   begin
                pop     hl
                bit     0,l
                jp      z,false140
; [153]     Right := Right + 1;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [154]     if Map[Row][Right] >= K then Break;
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false141
                jp      false140        ; Break
false141:
; [155]   end;
                jp      while139
false140:
; [156] 
; [157]   Top := Row;
                ld      de,ix
                ld      hl,-8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [158]   while Top > 0 do
while142:
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [159]   begin
                pop     hl
                bit     0,l
                jp      z,false143
; [160]     Top := Top - 1;
                ld      de,ix
                ld      hl,-8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [161]     if Map[Top][Column] >= K then Break;
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false144
                jp      false143        ; Break
false144:
; [162]   end;
                jp      while142
false143:
; [163] 
; [164]   Bottom := Row;
                ld      de,ix
                ld      hl,-10
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [165]   while Bottom < Size - 1 do
while145:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [166]   begin
                pop     hl
                bit     0,l
                jp      z,false146
; [167]     Bottom := Bottom + 1;
                ld      de,ix
                ld      hl,-10
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [168]     if Map[Bottom][Column] >= K then Break;
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false147
                jp      false146        ; Break
false147:
; [169]   end;
                jp      while145
false146:
; [170] 
; [171]   Score1 := (Column - Left) * (Right - Column);
                ld      de,ix
                ld      hl,-16
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                call    __mul16         ; Mul
                call    FLOAT
                exx
                pop     hl
                call    __storefp
; [172]   Score2 := (Row - Top) * (Bottom - Row);
                ld      de,ix
                ld      hl,-22
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                call    __mul16         ; Mul
                call    FLOAT
                exx
                pop     hl
                call    __storefp
; [173]   Score := Score1 * Score2;
                ld      de,ix
                ld      hl,10
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-16
                add     hl,de
                call    __loadfp
                pushfp
                ld      de,ix
                ld      hl,-22
                add     hl,de
                call    __loadfp
                exx
                popfp
                call    FPMUL
                exx
                pop     hl
                call    __storefp
; [174] 
; [175] (*  WriteLn(Row, ' ', Column, ' ', Left, ' ', Right, ' ', Top, ' ', Bottom); *)
; [176] end;
exit135:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [177] 
; [178] function ScoreB(Row, Column: Integer): Real;
; 
; [179] var
; [180]   K, Left, Right, Top, Bottom: Integer;
; [181]   Score1, Score2: Real;
; [182] begin
; var ScoreB(+10), Row(+8), Column(+6), K(-2), Left(-4), Right(-6), Top(-8), Bottom(-10), Score1(-16), Score2(-22)
; 
func148:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-22
                add     hl,sp
                ld      sp,hl
; [183]   K := Map[Row][Column];
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),de
; [184] 
; [185]   for Left := Column - 1 downto 0 do
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
                ld      de,0            ; Literal 0
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak151
forloop150:
; [186]     if Map[Row][Left] >= K then Break;
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false153
                jp      forbreak151     ; Break
false153:
fornext152:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak151
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                dec     de
                ld      (hl),de
                jp      forloop150
forbreak151:    pop     de              ; Cleanup limit
; [187] 
; [188]   for Right := Column + 1 to Size - 1 do
                ld      de,ix
                ld      hl,-6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak155
forloop154:
; [189]     if Map[Row][Right] >= K then Break;
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false157
                jp      forbreak155     ; Break
false157:
fornext156:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak155
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop154
forbreak155:    pop     de              ; Cleanup limit
; [190] 
; [191]   for Top := Row - 1 downto 0 do
                ld      de,ix
                ld      hl,-8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
                ld      de,0            ; Literal 0
                push    de
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak159
forloop158:
; [192]     if Map[Top][Column] >= K then Break;
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false161
                jp      forbreak159     ; Break
false161:
fornext160:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak159
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,(hl)
                dec     de
                ld      (hl),de
                jp      forloop158
forbreak159:    pop     de              ; Cleanup limit
; [193] 
; [194]   for Bottom  := Row + 1 to Size - 1 do
                ld      de,ix
                ld      hl,-10
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak163
forloop162:
; [195]     if Map[Bottom][Column] >= K then Break;
                ld      hl,global80     ; Get global Map
                push    hl
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,false165
                jp      forbreak163     ; Break
false165:
fornext164:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak163
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop162
forbreak163:    pop     de              ; Cleanup limit
; [196] 
; [197]   Score1 := (Column - Left) * (Right - Column);
                ld      de,ix
                ld      hl,-16
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                call    __mul16         ; Mul
                call    FLOAT
                exx
                pop     hl
                call    __storefp
; [198]   Score2 := (Row - Top) * (Bottom - Row);
                ld      de,ix
                ld      hl,-22
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                call    __mul16         ; Mul
                call    FLOAT
                exx
                pop     hl
                call    __storefp
; [199]   ScoreB := Score1 * Score2;
                ld      de,ix
                ld      hl,10
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-16
                add     hl,de
                call    __loadfp
                pushfp
                ld      de,ix
                ld      hl,-22
                add     hl,de
                call    __loadfp
                exx
                popfp
                call    FPMUL
                exx
                pop     hl
                call    __storefp
; [200] 
; [201] (*  WriteLn(Row, ' ', Column, ' ', Left, ' ', Right, ' ', Top, ' ', Bottom); *)
; [202] end;
exit149:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [203] 
; [204] procedure Part2;
; 
; [205] var
; [206]   I, J: Integer;
; [207]   K, Best: Real;
; [208] begin
; var I(-2), J(-4), K(-10), Best(-16)
; 
proc166:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-16
                add     hl,sp
                ld      sp,hl
; [209]   GotoXY(67, 3);
                ld      de,67           ; Literal 67
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                call    __gotoxy
; [210]   Write(#27'pTree scores'#27'q');
                ld      hl,string168
                call    __puts
; [211] 
; [212]   Best := 0;
                ld      de,ix
                ld      hl,-16
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                ld      hl,de
                call    FLOAT
                exx
                pop     hl
                call    __storefp
; [213] 
; [214]   for I := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak170
forloop169:
; [215]   begin
; [216]     GotoXY(67 + I mod 11, 4 + I / 11);
                ld      de,67           ; Literal 67
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Mod
                ex      hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,11           ; Literal 11
                pop     hl
                call    __sdiv16        ; Div
                ld      de,hl
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                call    __gotoxy
; [217]     Write('.');
                ld      de,46           ; Literal 46
                ld      hl,de
                ld      a,l
                call    __putc
; [218] 
; [219]     for J := 0 to Size - 1 do
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      hl,global82     ; Get global Size
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak173
forloop172:
; [220]     begin
; [221]       K := ScoreB(I, J);
                ld      de,ix
                ld      hl,-10
                add     hl,de
                push    hl
                push    hl
                push    hl
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                call    func148
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                popfp
                exx
                pop     hl
                call    __storefp
; [222]       if K > Best then Best := K;
                ld      de,ix
                ld      hl,-10
                add     hl,de
                call    __loadfp
                pushfp
                ld      de,ix
                ld      hl,-16
                add     hl,de
                call    __loadfp
                exx
                popfp
                call    __fltleq
                ld      hl,de
                ld      a,1
                xor     l
                ld      l,a
                bit     0,l
                jp      z,false175
                ld      de,ix
                ld      hl,-16
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-10
                add     hl,de
                call    __loadfp
                exx
                pop     hl
                call    __storefp
false175:
; [223]     end;
fornext174:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak173
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop172
forbreak173:    pop     de              ; Cleanup limit
; [224]   end;
fornext171:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                bit     0,l
                jp      z,forbreak170
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop169
forbreak170:    pop     de              ; Cleanup limit
; [225] 
; [226]   GotoXY(1, 15);
                ld      de,1            ; Literal 1
                push    de
                ld      de,15           ; Literal 15
                pop     hl
                call    __gotoxy
; [227]   WriteLn('Part 2: ', Best:0:0, ' scenic score');
                ld      hl,string176
                call    __puts
                ld      de,ix
                ld      hl,-16
                add     hl,de
                call    __loadfp
                pushfp
                ld      de,0            ; Literal 0
                push    de
                ld      de,0            ; Literal 0
                ld      bc,de
                pop     de
                exx
                popfp
                call    __putf_fix
                ld      hl,string177
                call    __puts
                call    __newline
; [228] end;
exit167:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [229] 
; [230] begin
; 
; var Mem(0), HeapPtr(0), AssertPassed(0), AssertFailed(0), Map(0), Visible(0), Size(0), NumVisible(0)
; 
main:           call    __init
                ld      ix,0
                add     ix,sp
; [231]   ClrScr;
                call    __clrscr
; [232]   WriteLn('*** AoC 2022.08 Treetop Tree House ***');
                ld      hl,string179
                call    __puts
                call    __newline
; [233] 
; [234]   Load;
                call    proc84
; [235]   Part1;
                call    proc98
; [236]   Part2;
                call    proc166
; [237] end.
exit178:        call    __done
                ret
; 
string58:       db      0
; 
string86:       db      15,27,"pInput file ",27,"q"
; 
string87:       db      12,"INPUT   .TXT"
; 
string100:      db      15,27,"pWest view  ",27,"q"
; 
string108:      db      15,27,"pEast view  ",27,"q"
; 
string116:      db      15,27,"pNorth view ",27,"q"
; 
string124:      db      15,27,"pSouth view ",27,"q"
; 
string132:      db      8,"Part 1: "
; 
string133:      db      14," visible trees"
; 
string168:      db      15,27,"pTree scores",27,"q"
; 
string176:      db      8,"Part 2: "
; 
string177:      db      13," scenic score"
; 
string179:      db      38,"*** AoC 2022.08 Treetop Tree House ***"
; 
display:        ds      32              ; Display
; 
eof:                                    ; End of file
; 
; HEAP:
; 
; end
; 
