; --------------------------------------
; zasm: assemble "monkey.z80"
; date: 2023-04-08 16:49:01
; --------------------------------------


; 
; program monkey.pas
; 
CPM:            equ     1               ; Target is CP/M .com file
; 
                include "/Users/joerg/Projekte/pl0/pl0.z80"
;
; PL0 built-in assembler functions
;

#if defined(CPM)
                org     $100
#endif

#if defined(NXT)
                org     $2000
#endif

                jp      main

;
; Some stuff shared between the routines
;
#if defined(CPM)
__buffer:       ds      32
#endif

#if defined(NXT)
__saved_iy:     dw      0
__win_handle:   dw      0
__buffer:       equ     23698
#endif

;
; Boolean literals
;
__boolean1:     db      4,"True"
__boolean0:     db      5,"False"
__boolean_enum: dw __boolean0, __boolean1

;
; Signed 16 bit '=' check (with help from Ped7g)
;
; In:   HL (left), DE (right)
; Out:  A=0 if false, A=1 if true
;
__int16_eq:     xor a
                sbc hl,de
                ; add hl,de
                ret nz
                inc a
                ret

;
; Signed 16 bit '<>' check (with help from Ped7g)
;
; In:   HL (left), DE (right)
; Out:  A=0 if false, A=1 if true
;
__int16_neq:    xor a
                sbc hl,de
                ; add hl,de
                ret z
                inc a
                ret

;
; Signed 16 bit 'lt' check (with help from Ped7g)
;
; In:   HL (left), DE (right)
; Out:  A=0 if false, A=1 if true
;
__int16_lt:     xor a
                sbc hl,de
                ; add hl,de
                jp pe,__int16_lt_of
                ret p
                inc a
                ret
__int16_lt_of:  ret m
                inc a
                ret

;
; Signed 16 bit '>=' check (with help from Ped7g)
;
; In:   HL (left), DE (right)
; Out:  A=0 if false, A=1 if true
;
__int16_geq:    xor a
                sbc hl,de
                ; add hl,de
                jp pe,__int16_geq_of
                ret m
                inc a
                ret
__int16_geq_of: ret p
                inc a
                ret

; Signed bc <= de <= hl check

__int16_case:   push    de
                call    __int16_geq
                pop     hl
                and     a
                ret     z
                push    hl
                ld      de,bc
                call    __int16_geq
                pop     de
                and     a
                ret     z
                inc     a
                ret

; Signed 16 bit left-shift 
;
; Entry: HL (Number), E (number of Bits)
; Exit:  HL (Number)
__int_shl:      ld a,e
                and a
                ret z
                ld b,a
__int_shl1:
                sla l
                rl h
                djnz __int_shl1
                ret

; Signed 16 bit right-shift 
;
; Entry: HL (Number), E (number of Bits)
; Exit:  HL (Number)
__int_shr:      ld a,e
                and a
                ret z
                ld b,a
__int_shr1:
                srl h
                rr l
                djnz __int_shr1
                ret

;
; Signed 16 bit multiplication (taken from Leventhal/Saville)
;
; Entry:  HL (multiplicand), DE (multiplier)
; Exit:   HL (product)
; Uses:   AF, BC
;
__mul16:        ld      c,l
                ld      b,h
                ld      hl,0
                ld      a,15
__mul16a:       sla     e
                rl      d
                jr      nc,__mul16b
                add     hl,bc
__mul16b:       add     hl,hl
                dec     a
                jr      nz,__mul16a
                or      d
                ret     p
                add     hl,bc
                ret

;
; Signed 16 bit division (taken from Leventhal/Saville)
;
; Entry:  HL (dividend), DE (divisior)
; Exit:   HL (quotient), DE (remainder), CF (div-by-zero)
; Uses:   AF, BC
;
__sdiv16:       ld      a,h
                ld      (__srem),a
                xor     d
                ld      (__squot),a
                ld      a,d
                or      a
                jp      p,__chkde
                sub     a
                sub     e
                ld      e,a
                sbc     a,a
                sub     d
                ld      d,a
__chkde:        ld      a,h
                or      a
                jp      p,__dodiv
                sub     a
                sub     l
                ld      l,a
                sbc     a,a
                sub     h
                ld      h,a
__dodiv:        call    __udiv16
                ret     c
                ld      a,(__squot)
                or      a
                jp      p,__dorem
                sub     a
                sub     l
                ld      l,a
                sbc     a,a
                sub     h
                ld      h,a
__dorem:        ld      a,(__srem)
                or      a
                ret     p
                sub     a
                sub     e
                ld      e,a
                sbc     a,a
                sub     d
                ld      d,a
                ret
__udiv16:       ld      a,e
                or      d
                jr      nz,__divide
                ld      hl,0
                ld      d,h
                ld      e,l
                scf
                ret
__divide:       ld      c,l
                ld      a,h
                ld      hl,0
                ld      b,16
                or      a
__dvloop:       rl      c
                rla
                rl      l
                rl      h
                push    hl
                sbc     hl,de
                ccf
                jr      c,__drop
                ex      (sp),hl
__drop:         inc     sp
                inc     sp
                djnz    __dvloop
                ex      de,hl
                rl      c
                ld      l,c
                rla
                ld      h,a
                or      a
                ret

__squot:        ds      1
__srem:         ds      1
__count:        ds      1

;
; Multiplication by 10
;
; Entry:  HL (multiplicand)
; Exit:   HL (product)
; Uses:   DE
;
__mul10:    
                ex      hl,de
                add     hl,hl
                ld      de,hl
                add     hl,hl
                add     hl,hl
                add     hl,de
                ex      hl,de
                ret

;
; Division by 10 (taken from Z80 Heaven)
;
; Entry:  HL (dividend)
; Exit:   HL (quotient), A (remainder)
; Uses:   AF, BC
;
__div10:    
                ld      bc,$0D0A
                xor     a
                add     hl,hl
                rla
                add     hl,hl
                rla
                add     hl,hl
                rla
__div10a:       add     hl,hl
                rla
                cp      c
                jr c,   __div10b
                sub c
                inc l
__div10b:       djnz __div10a
                ret

; Fallthrough intended
__abs16:
                bit     7,h
                ret     z

; Negation from Z80 Heaven
__neg16:
                xor     a
                sub     l
                ld      l,a
                sbc     a,a
                sub     h
                ld      h,a
                ret

;
;
;
;

__random:
    ; ex hl,de
    call __rand16
    call __sdiv16
    ex hl,de
    ret
    
;#define smc    ;uncomment if you are using SMC
__rand16:
;;collaboration by Zeda with Runer112
;;160cc or 148cc if using SMC
;;26 bytes
;;cycle: 4,294,901,760 (almost 4.3 billion)
#if defined(smc)
seed1=$+1
    ld hl,9999
#else
    ld hl,(seed1)
#endif
    ld b,h
    ld c,l
    add hl,hl
    add hl,hl
    inc l
    add hl,bc
    ld (seed1),hl
#if defined(smc)
seed2=$+1
    ld hl,9999
#else
    ld hl,(seed2)
#endif
    add hl,hl
    sbc a,a
    and %00101101
    xor l
    ld l,a
    ld (seed2),hl
    add hl,bc
    res 7,h
    ret
seed1:              dw 1234
seed2:              dw 5678

; String Compare Leventhal Saville P.290
;
; HL string 1
; DE string 2
; Result: Z=1, C=0 1<2
; Z =0, C=0 1>2
; Z=0, C=1 1<2


__strcmp:
        ld      a,(hl)
        ld      (__lens1),a
        ld      a,(de)
        ld      (__lens2),a
        cp      (hl)
        jr      c,__begcmp
        ld      a,(hl)
__begcmp:
        or      a
        jr      z,__cmplen
        ld      b,a
        ex      de,hl
__cmplp:
        inc     hl
        inc     de
        ld      a,(de)
        cp      (hl)
        ret     nz
        djnz    __cmplp
__cmplen:
        ld      a,(__lens1)
        ld      hl,__lens2
        cp      (hl)
        ret
__lens1:
        ds      1
__lens2:
        ds      1

; String concatenate
; HL = String 1, DE = String 2, B = max len, CF=1 if shortened
__strcat:
        ld      (__s1adr),hl
        push    bc
        ld      a,(hl)
        ld      (__s1len),a
        ld      c,a
        ld      b,0
        add     hl,bc
        inc     hl
        ld      a,(de)
        ld      (__s2len),A
        inc     de
        pop     bc
        ld      c,a
        ld      a,(__s1len)
        add     a,c
        jr      c,__toolng
        cp      b
        jr      z,__lenok
        jr      c,__lenok
__toolng:
        ld      a,255
        ld      (__strgov),a
        ld      a,(__s1len)
        ld      c,a
        ld      a,b
        sub     c
        ret     c
        ld      (__s2len),a
        ld      a,b
        ld      (__s1len),a
        jr      __docat
__lenok:
        ld      (__s1len),a
        sub     a
        ld      (__strgov),a
__docat:
        ld      a,(__s2len)
        or      a
        jr      z,__exit
        ld      c,a
        ld      b,0
        ex      de,hl
        ldir
__exit:
        ld      a,(__s1len)
        ld      hl,(__s1adr)
        ld      (hl),a
        ld      a,(__strgov)
        rra
        ret
__s1adr:
        ds      2
__s1len:
        ds      1
__s2len:
        ds      1
__strgov:
        ds      1

; String pos
__strpos:
        ld      (__string),hl
        ex      de,hl
        ld      a,(hl)
        or      a
        jr      z,__notfnd
        inc     hl
        ld      (__substg),hl
        ld      (__sublen),a
        ld      c,a
        ld      a,(de)
        or      a
        jr      z,__notfnd
        sub     c
        jr      c,__notfnd
        inc     a
        ld      b,a
        sub     a
        ld      (__index),a
__slp1:
        ld      hl,__index
        inc     (hl)
        ld      hl,__sublen
        ld      c,(hl)
        ld      hl,(__string)
        inc     hl
        ld      (__string),hl
        ld      de,(__substg)
__cmplp2:
        ld      a,(de)
        cp      (hl)
        jr      nz,__slp2
        dec     c
        jr      z,__found
        inc     hl
        inc     de
        jr      __cmplp2
__slp2:
        djnz    __slp1
        jr      __notfnd
__found:
        ld      a,(__index)
        ret
__notfnd:
        sub     a
        ret
__string:
        ds      2
__substg:
        ds      2
__slen:
        ds      1
__sublen:
        ds      1
__index:
        ds      1


; strcpy
__strcpy:
        ld      (__maxlen),a
        sub     a
        ld      (de),a
        ld      (__cpyerr),a
        or      b
        ret     z
        ld      a,(__maxlen)
        or      a
        jr      z,__erexit
        ld      a,c
        or      a
        jr      z,__erexit
        ld      a,(hl)
        cp      c
        ret     c
        ld      a,c
        add     a,b
        jr      c,__recalc
        dec     a
        cp      (hl)
        jr      c,__cnt1ok
        jr      z,__cnt1ok
__recalc:
        ld      a,255
        ld      (__cpyerr),a
        ld      a,(hl)
        sub     c
        inc     a
        ld      b,a
__cnt1ok:
        ld      a,(__maxlen)
        cp      b
        jr      nc,__cnt2ok
        ld      b,a
        ld      a,255
        ld      (__cpyerr),a
__cnt2ok:
        ld      a,b
        or      a
        jr      z,__erexit
        ld      b,0
        add     hl,bc
        ld      (de),a
        ld      c,a
        inc     de
        ldir
        ld      a,(__cpyerr)
__okexit:
        or      a
        ret     z
__erexit:
        scf
        ret
__maxlen:
        ds      1
__cpyerr:
        ds      1

;Insert
__strins:
        sub     a
        ld      (__inserr),a
        ld      a,(de)
        or      a
        ret     z
__idx0:
        ld      a,c
        or      a
        scf
        ret     z
__chklen:
        ld      a,(de)
        add     a,(hl)
        jr      c,__trunc
        cp      b
        ld      a,(de)
        jr      c,__idxlen
        jr      z,__idxlen
__trunc:
        ld      a,255
        ld      (__inserr),a
        ld      a,b
        sub     (hl)
        ret     c
        scf
        ret     z
__idxlen:
        ld      b,a
        ld      a,(hl)
        cp      c
        jr      nc,__lenok2
        ld      c,a
        add     a,b
        ld      (hl),a
        ex      de,hl
        ld      a,c
        inc     a
        add     a,e
        ld      e,a
        jr      nc,__idxl1
        inc     d
__idxl1:
        ld      a,255
        ld      (__inserr),a
        jr      __mvesub
__lenok2:
        push    bc
        push    de
        ld      e,a
        ld      d,0
        add     a,b
        ld      (hl),a
        ld      a,e
        sub     c
        inc     a
        add     hl,de
        ld      e,l
        ld      d,h
        ld      c,b
        ld      b,0
        add     hl,bc
        ex      de,hl
        ld      c,a
        lddr
        ex      de,hl
        inc     de
        pop     hl
        pop     bc
__mvesub:
        inc     hl
        ld      c,b
        ld      b,0
        ldir
        ld      a,(__inserr)
        rra
        ret
__inserr:
        ds      1

; Delete
__strdel:
        sub     a
        ld      (__delerr),a
        or      b
        ret     z
        ld      a,c
        or      a
        scf
        ret     z
        ld      a,(hl)
        cp      c
        ret     c
        ld      a,c
        add     a,b
        jr      c,__trunc2
        ld      e,a
        dec     a
        cp      (hl)
        jr      c,__cntok
        jr      z,__trunc2
        ld      a,255
        ld      (__delerr),a
__trunc2:
        ld      a,c
        dec     a
        ld      (hl),a
        ld      a,(__delerr)
        rra
        ret
__cntok:
        ld      a,(hl)
        ld      d,a
        sub     b
        ld      (hl),a
        ld      a,d
        sub     e
        inc     a
        push    hl
        ld      b,0
        add     hl,bc
        ex      (sp),hl
        ld      d,0
        add     hl,de
        pop     de
        ld      c,a
        ldir
__okexit2:
        or      a
        ret
__delerr:
        ds      1        
;
; String "equal" check. Arguments and result on stack.
;
; Entry:    -
; Exit:     -
; Uses:     HL,DE,BC,AF
;
__streq:
        ld      hl,258
        add     hl,sp
        ld      de,hl
        dec     h
        ld      a,(de)
        cp      (hl)
        jr      nz,__streq0     ; Fast track if lengths differ
        call    __strcmp
        jr      z,__streq1
__streq0:
        ld      de,0

;        ld      (hl),de
        ret
__streq1:
        ld      de,1
;        ld      (hl),de
;        ld      a,1
        ret

;
; String "less than" check. Arguments and result on stack.
;
; Entry:    -
; Exit:     -
; Uses:     HL,DE,BC,AF
;
__strlt:
        ld      hl,258
        add     hl,sp
        ld      de,hl
        dec     d
        call    __strcmp
        jr      c,__strlt1
__strlt0:
;        ld      a,0
        ld      de,0
;        ld      (hl),de
        ret
__strlt1:
        ld      de,1
;        ld      (hl),de
;        ld      a,1
        ret

;
; String "less than or equal" check. Arguments and result on stack.
;
; Entry:    -
; Exit:     -
; Uses:     HL,DE,BC,AF
;
__strleq:
        ld      hl,258
        add     hl,sp
        ld      de,hl
        dec     d
        call    __strcmp
        jr      z,__strleq1
        jr      c,__strleq1
__strleq0:
        ld      de,0
;        ld      (hl),de
;        ld      a,0
        ret
__strleq1:
        ld      de,1
;        ld      (hl),de
;        ld      a,1
        ret

; Concat
__concat:
        ld      hl,514
        add     hl,sp
        ld      (hl),0
        ld      de,hl
        dec     d
        push    hl
        push    de
        ld      b,255
        call    __strcat
        pop     de
        dec     d
        pop     hl
        ld      b,255
        call    __strcat
        ret

; Concat
__stradd:
        ld      hl,258
        add     hl,sp
        ld      de,hl
        dec     d
        ld      b,255
        call    __strcat
        ret

__pos:
        ld      hl,514
        add     hl,sp
        push    hl
        dec     h
        ld      de,hl
        dec     d
        ex      de,hl
        call    __strpos
        pop     hl
        ld      (hl),a
        inc     hl
        ld      (hl),0
        ret

__copy:
        ld      hl,2
        add     hl,sp
        ld      b,(hl)
        inc     hl
        inc     hl
        ld      c,(hl)
        inc     hl
        inc     hl
        ld      de,hl
        inc     d
        ld      a,255
        call    __strcpy
        ret

__insert:
        ld      hl,2
        add     hl,sp
        ld      c,(hl)
        inc     hl
        inc     hl
        ld      a,(hl)
        inc     hl
        ld      de,hl
        ld      h,(hl)
        ld      l,a
        inc     de

        ld      b,255
        call    __strins
        ret

__delete:
        ld      hl,2
        add     hl,sp
        ld      b,(hl)
        inc     hl
        inc     hl
        ld      c,(hl)
        inc     hl
        inc     hl
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        ld      l,a
        call    __strdel
        ret

__str_int:
        ld      hl,2
        add     hl,sp
        ld      bc,(hl)
        inc     hl
        inc     hl
        ld      de,(hl)
        ld      hl,bc
        push    hl
        inc     hl
        call    __itoa
        pop     hl
        ld      (hl),a
        ret

__val_int:
        ld      hl,6
        add     hl,sp
        ld      a,(hl)
        inc     hl
        call    __atoi
        ld      hl,4        
        add     hl,sp
        ld      bc,(hl)
        ld      hl,bc
        ld      (hl),de
        pop     de
        ld      hl,260
        add     hl,sp
        ld      sp,hl
        push    de
        ret                     ; FIXME: Error reporting 

__val_float:
        ld      hl,6
        add     hl,sp
;        ld      a,(hl)
;        inc     hl
        call    __atof
        exx
        pop     de
        pop     bc
        pop     hl
        call    __storefp
        exx
        ld      hl,256
        add     hl,sp
        ld      sp,hl
        push    de
        ret                     ; FIXME: Error reporting 

;
; String length. Arguments and result on stack.
;
; Entry:    -
; Exit:     -
; Uses:     HL,DE
;
__length:
        ld      hl,2
        add     hl,sp
        ld      d,0
        ld      e,(hl)
        inc     h
        ld      (hl),de
        ret

;
; Load string from HL to stack, return properly.
;
__loadstr:
        pop     bc
        ex      de,hl
        ld      hl,-256
        add     hl,sp
        ld      sp,hl
        ex      de,hl
        push    bc
        ld      a,255
        call    __movestr
        ret

;
; Store string of max length A from stack to address, cleanup stack, return properly.
;
__storestr:
        ld      hl,258
        add     hl,sp
        ld      de,(hl)
        dec     h
        call    __movestr
        pop     bc
        ld      hl,258
        add     hl,sp
        ld      sp,hl
        push    bc
        ret

;
; Move string of max length A from HL to DE, bypassing the stack.
;
__movestr:
        ld      b,(hl)
        cp      b
        jp      c,__movestr_1
        ld      a,b
__movestr_1:
        ld      (de),a
        and     a
        ret     z
        inc     hl
        inc     de
        ld      b,0
        ld      c,a
        ldir
        ret

#include "math48.z80"
;       Math48 Floating Point Package
;       Version 1.1 Revision 1
;       by Anders Hejlsberg
;       2532 Bytes

;HOPTABEL

        JP   FPADD
        JP   FPSUB
        JP   FPMUL
        JP   FPDIV
        JP   MOD
        JP   PWR
        JP   CMP

        JP   SQR
        JP   LN
        JP   EXP
        JP   LOG
        JP   SIN
        JP   COS
        JP   TAN
        JP   ATN
        JP   ACPI
        JP   INT
        JP   FRAC

        JP   EQUAL
        JP   MUL10
        JP   FIX
        JP   FLOAT

        JP   FSTRS
        JP   FSTRR
        JP   CNVN


SIGN:   EQU  80H
EXPN:   EQU  80H

IWIDTH: EQU  0F0H
FWIDTH: EQU  0FH


;FLOATING POINT ADDITION.

FPADD:  EXX             ;Er AC negativ?
        BIT  7,B
        EXX
        JP   NZ,SUB1    ;Ja => SUB1

ADD1:   EXX             ;Er AC' nul?
        LD   A,L
        OR   A
        EXX
        RET  Z          ;Ja => Returner

        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        EXX

        LD   A,L        ;Er AC nul?
        OR   A
        JR   NZ,ADD2    ;Nej => ADD2
        EXX             ;Returner AC'
        RES  7,B        ;Positivt
        JR   ADD10

ADD2:   PUSH BC         ;Gem fortegn
        SET  7,B        ;Saet MSB
        XOR  A          ;Saet Z'
        EX   AF,AF'
        EXX
        SET  7,B        ;Saet MSB'
        LD   A,L        ;A=EXP'-EXP
        EXX
        SUB  L
        JR   Z,ADD4     ;EXP=EXP' => ADD4
        JR   NC,ADD3    ;EXP<EXP' => ADD3

        NEG             ;Goer A positiv
        EX   AF,AF'     ;Nulstil Z'
        DEC  A
        EX   AF,AF'
        EXX             ;Juster AC'

ADD3:   CALL SRIGHT     ;Skift til hoejre
        INC  L          ;Er EXP=EXP'?
        DEC  A
        JR   NZ,ADD3    ;Nej => ADD3

        EX   AF,AF'     ;Var det AC'?
        JR   Z,ADD4     ;Nej => ADD4
        EXX             ;Ja => Ombyt

ADD4:   POP  AF         ;Hent AC fortegn
        AND  SIGN       ;Negativt?
        JR   NZ,ADD5    ;Ja => ADD5

        CALL ADDAC      ;MANT=MANT+MANT'
        JR   NC,ADD9    ;Ikke overflow => ADD9
        CALL RIGHT      ;Roter til hoejre
        OR   A
        INC  L          ;Juster exponent
        JR   NZ,ADD9
        SCF
        JR   ADD10

ADD5:   CALL CMPAC      ;Sammenlign
        CCF             ;Komplementer carry og
        PUSH AF         ;gem som fortegn
        JR   Z,ADDZ     ;AC=AC' => ADDZ
        JR   C,ADD6     ;AC>AC' => ADD6
        EXX             ;AC<AC' => Ombyt
ADD6:   CALL SUBAC      ;MANT=MANT-MANT'
ADD7:   BIT  7,B        ;Normaliseret?
        JR   NZ,ADD8    ;Ja => ADD8
        CALL SLEFT      ;Skift til venstre
        INC  L          ;Er exponent -128?
        DEC  L
        JR   Z,ADDZ     ;Ja => AC lig nul
        DEC  L          ;Traek 1 fra exponent
        JR   ADD7

ADDZ:   CALL ZERO

ADD8:   POP  AF         ;Hent fortegn
ADD9:   JR   C,ADD9A    ;Carry => negativt
        RES  7,B
ADD9A:  OR   A

ADD10:  EXX             ;Hent AC'
        POP  HL
        POP  DE
        POP  BC
        EXX
        RET


;FLOATING POINT SUBTRAKTION

FPSUB:  EXX             ;Er AC negativ?
        BIT  7,B
        EXX
        JP   NZ,ADD1    ;Ja => ADD1

SUB1:   CALL FPNEG      ;AC=-AC
        CALL ADD1       ;Laeg AC' til AC

FPNEG:  INC  L          ;Er AC nul?
        DEC  L
        RET  Z          ;Ja => Returner
        EX   AF,AF'     ;Gem carry
        LD   A,B        ;Komplementer fortegn
        XOR  SIGN
        LD   B,A
        EX   AF,AF'     ;Hent carry
        RET


;FLOATING POINT DIVISION.

FPDIV:  EXX             ;Er AC' nul?
        INC  L
        DEC  L
        EXX
        SCF
        RET  Z          ;Ja => Overflow

        LD   A,L        ;Er AC nul?
        OR   A
        RET  Z          ;Ja => Returner

        EXX             ;Subtraher exponenter
        SUB  L
        EXX
        CCF             ;Juster exponent og
        CALL EXPSGN     ;udregn fortegn

        PUSH HL         ;Opret 6 bytes work-
        PUSH HL         ;space
        PUSH HL
        ADD  IX,SP

        EXX             ;5 bytes
        LD   L,5
        EXX
        LD   A,8        ;Med hver 8 bits

DIVI1:  EX   AF,AF'     ;Gem taeller
        CALL CMPAC      ;Er MANT>MANT'
        JR   C,DIVI2    ;Nej => DIVI2
        CALL SUBAC      ;Traek AC' fra AC

DIVI2:  CCF             ;Komplementer carry
        RL   L          ;Roter ind i resultat
        EX   AF,AF'     ;Hent bittaeller
        DEC  A          ;Byte faerdig?
        JR   NZ,DIVI3   ;Nej => DIVI3

        LD   (IX+5),L   ;Gem byte i buffer
        DEC  IX         ;Peg til naeste
        EXX             ;Er 5 bytes klaret?
        DEC  L
        EXX
        JR   Z,DIVI4    ;Ja => DIVI4
        LD   A,8        ;8 bits

DIVI3:  CALL SLEFT      ;Skift AC til venstre
        JR   NC,DIVI1   ;Ingen carry => DIVI1

        EX   AF,AF'     ;Gem taeller
        CALL SUBAC      ;MANT=MANT-MANT'
        OR   A          ;Nulstil carry
        JR   DIVI2

DIVI4:  CALL SLEFT      ;Udregn afrundingsbit
        JR   C,DIVI5
        CALL CMPAC
        CCF

DIVI5:  POP  HL         ;Hent resultat
        POP  DE
        POP  BC
        BIT  7,B        ;Normaliseret?
        JR   NZ,DIVI6   ;Ja => DIVI6

        CALL LEFT       ;Roter afrundingsbit
        JR   MUL5       ;ind i resultatet

DIVI6:  INC  L          ;Laeg 1 til exponent
        JR   NZ,MUL5
        DEC  L
        SCF
        JR   MUL5A


;FLOATING POINT MULTIPLIKATION

FPMUL:  EXX             ;Er AC' nul?
        LD   A,L
        OR   A
        EXX
        JP   Z,ZERO     ;Ja => Resultat 0

        LD   A,L        ;Er AC nul?
        OR   A
        RET  Z          ;Ja => Retur

        EXX             ;Adder exponenter
        ADD  A,L
        EXX             ;Juster exponent og
        CALL EXPSGN     ;udregn fortegn

        PUSH BC         ;Gem AC
        PUSH DE
        PUSH HL
        ADD  IX,SP      ;Peg IX til AC

        CALL ZERO       ;Nulstil resultat
        EXX             ;5 bytes
        LD   L,5
        EXX

MUL1:   LD   A,8        ;Bittaeller lig 8
        INC  IX         ;Hent ny byte
        LD   L,(IX+0)

MUL2:   EX   AF,AF'     ;Gem taeller
        RR   L          ;Roter byte til hoejre
        JR   NC,MUL3    ;Hvis carry saa laeg
        CALL ADDAC      ;AC' til resultatet

MUL3:   CALL RIGHT      ;Roter res. til hoejre
        EX   AF,AF'     ;Hent taeller
        DEC  A          ;Byte faerdig?
        JR   NZ,MUL2    ;Nej => MUL2
        EXX             ;5 bytes klaret?
        DEC  L
        EXX
        JR   NZ,MUL1    ;Nej => MUL1

        LD   L,(IX-5)   ;Hent exponent
        BIT  7,B        ;Normaliseret?
        JR   NZ,MUL4    ;Ja => MUL4

        EX   AF,AF'     ;Hent sidste carry
        CALL LEFT       ;Roter res. til venstre
        INC  L          ;Traek 1 fra exponent
        DEC  L
        JR   Z,MUL4
        DEC  L

MUL4:   POP  AF         ;Fjern workspace
        POP  AF
        POP  AF

MUL5:   OR   A          ;Status = OK
MUL5A:  EX   AF,AF'     ;Gem status
        POP  AF         ;Hent res. fortegn
        EXX
        POP  BC         ;Hent AC' fortegn
        POP  HL         ;Hent AC' exponent
        EXX
        POP  IX         ;Hent IX
        RES  7,B        ;Erstat MSB i AC med
        OR   B          ;fortegn
        LD   B,A
        EX   AF,AF'     ;Hent status
        INC  L
        DEC  L
        CALL Z,ZERO
        RET

;Juster exponent og udregn fortegn.

EXPSGN: JR   C,EXPS1    ;Carry => EXPS1
        ADD  A,EXPN     ;Juster exponent
        JR   C,EXPS2    ;Carry => EXPS2
        JR   EXPS3      ;Underflow

EXPS1:  ADD  A,EXPN     ;Juster exponent
        JR   C,EXPS3    ;carry => Overflow

EXPS2:  LD   L,A        ;Gem i exponent
        EX   (SP),IX    ;Gem IX
        EXX
        PUSH HL         ;Gem AC' exponent
        PUSH BC         ;Gem AC' fortegn
        LD   A,B        ;Udregn nyt fortegn
        SET  7,B
        EXX
        XOR  B
        AND  SIGN
        PUSH AF
        SET  7,B
        PUSH IX
        LD   IX,0       ;Nulstil IX
        RET

EXPS3:  POP  HL         ;Juster stakken
        RET  C          ;Carry => Returner

;Nulstil AC.

ZERO:   XOR  A          ;Nulstil carry, expo-
        LD   L,A        ;nent og mantissa
        LD   B,A
        LD   C,A
        LD   D,A
        LD   E,A
        LD   H,A
        RET

;Roter AC til hoejre.

SRIGHT: OR   A
RIGHT:  RR   B
        RR   C
        RR   D
        RR   E
        RR   H
        RET

;Roter AC til venstre.

SLEFT:  OR   A
LEFT:   RL   H
        RL   E
        RL   D
        RL   C
        RL   B
        RET

;Laeg AC' til AC.

ADDAC:  LD   A,H
        EXX
        ADD  A,H
AAC1:   EXX
        LD   H,A
        LD   A,E
        EXX
        ADC  A,E
        EXX
        LD   E,A
        LD   A,D
        EXX
        ADC  A,D
        EXX
        LD   D,A
        LD   A,C
        EXX
        ADC  A,C
        EXX
        LD   C,A
        LD   A,B
        EXX
        ADC  A,B
        EXX
        LD   B,A
        RET

;Traek AC' fra AC.

SUBAC:  LD   A,H
        EXX
        SUB  H
SAC1:   EXX
        LD   H,A
        LD   A,E
        EXX
        SBC  A,E
        EXX
        LD   E,A
        LD   A,D
        EXX
        SBC  A,D
        EXX
        LD   D,A
        LD   A,C
        EXX
        SBC  A,C
        EXX
        LD   C,A
        LD   A,B
        EXX
        SBC  A,B
        EXX
        LD   B,A
        RET

;Sammenlign AC med AC'.

CMPAC:  LD   A,B
        EXX
        CP   B
        EXX
        RET  NZ
        LD   A,C
        EXX
        CP   C
        EXX
        RET  NZ
        LD   A,D
        EXX
        CP   D
        EXX
        RET  NZ
        LD   A,E
        EXX
        CP   E
        EXX
        RET  NZ
        LD   A,H
        EXX
        CP   H
        EXX
        RET


;FLOATING POINT COMPARE.

CMP:    EXX             ;Er fortegn ens?
        LD   A,B
        EXX
        XOR  B
        JP   P,CMP1     ;Ja => CMP1
        LD   A,B        ;Fortegn fra AC til
        RLA             ;carry
        RET

CMP1:   BIT  7,B        ;Negative tal?
        JR   Z,CMP2     ;Nej => CMP2

        CALL CMP2       ;Sammenlign abs.vaerdi
        RET  Z          ;Ens => Returner
        CCF             ;Complementer resultat
        RET

CMP2:   LD   A,L        ;Er exponenter ens?
        EXX
        CP   L
        EXX
        RET  NZ         ;Nej => Returner
        OR   A          ;Er exponenter nul?
        RET  Z          ;Ja => Returner
        JP   CMPAC      ;Sammenlign AC med AC'


;FLOATING POINT INTEGER.

INT:    LD   A,L        ;Er exponent mindre
        SUB  EXPN+1     ;end nul?
        JP   C,ZERO     ;Ja => Resultat nul
        INC  A

        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        EX   AF,AF'
        CALL ZERO       ;Nulstil AC'
        EX   AF,AF'

INT1:   SCF             ;Saet alle bits der har
        CALL RIGHT      ;en exponent stoerre
        DEC  A          ;end eller lig nul
        JR   NZ,INT1

        EXX             ;Nulstil alle bits i AC
        LD   A,H        ;der har en exponent
        EXX             ;mindre end 0
        AND  H
        EXX
        LD   H,A
        LD   A,E
        EXX
        AND  E
        EXX
        LD   E,A
        LD   A,D
        EXX
        AND  D
        EXX
        LD   D,A
        LD   A,C
        EXX
        AND  C
        EXX
        LD   C,A
        LD   A,B
        EXX
        AND  B
        EXX
        LD   B,A
INT2:   JP   ADD10      ;Hent AC'


;FLOATING POINT FRACTION.

;FRAC(X) udregnes af X-INT(X).

FRAC:   EXX
        PUSH BC
        PUSH DE
        PUSH HL
        EXX

        CALL EQUAL
        EXX
        CALL INT
        EXX
        CALL FPSUB
        JR   INT2


;MODULUS.

;X MOD Y beregnes af FRAC(X/Y)*Y.

MOD:    CALL FPDIV
        RET  C
        CALL FRAC
        JP   FPMUL


;KVADRATROD.

;Kvadratroden beregnes med Newton-Raphson
;iterationsmetoden. Et gaet udregnes ud fra
;det foregaaende gaet efter formelen:
;I(n+1)=(X/I(n)+I(n))/2.
;Som foerste gaet halveres X's exponent.
;Der fortsaettes indtil ABS(I(n+1)-I(n)) er
;mindre end den halve exponent af X minus 20.

SQR:    LD   A,L        ;Er AC nul?
        OR   A
        RET  Z          ;Ja => Returer

        BIT  7,B        ;Er AC negativ?
        SCF             ;Saet carry
        RET  NZ         ;Ja => Returner

        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        CALL EQUAL      ;AC'=AC
        LD   A,L        ;Foerste iteration:
        ADD  A,EXPN     ;halver exponenten
        SRA  A
        ADD  A,EXPN
        LD   L,A        ;Sammenligningsvaerdi
        SUB  20         ;er den halve exponent
        PUSH AF         ;Gem s.vaerdi
        EXX

SQR1:   PUSH BC         ;Gem tallet
        PUSH DE
        PUSH HL
        CALL FPDIV      ;Divider med og adder
        CALL FPADD      ;forrige gaet
        DEC  L          ;Halver
        PUSH BC         ;Gem dette gaet
        PUSH DE
        PUSH HL
        CALL FPSUB      ;Udregn forskellen mel-
        LD   A,L        ;lem de to gaet
        POP  HL         ;Hent det nye gaet
        POP  DE
        POP  BC
        EXX
        POP  HL         ;Hent tallet
        POP  DE
        POP  BC
        EX   (SP),HL    ;Hent s.vaerdi ind i H
        CP   H
        EX   (SP),HL    ;Fortsaet indtil forsk.
        JR   NC,SQR1    ;er lille nok

        POP  AF         ;Fjern s.vaerdi
        EXX
        OR   A          ;Nulstil carry
SQR2:   JP   ADD10      ;Hent AC'


;TANGENS.

;TAN(X) beregnes af SIN(X)/COS(X)

TAN:    EXX
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        CALL EQUAL
        CALL COS
        EXX
        CALL SIN
        CALL FPDIV
        JR   SQR2


;COSINUS.

;COS(X) beregnes af SIN(PI/2-X)

COS:    EXX
        PUSH BC
        PUSH DE
        PUSH HL
        CALL ACPI
        DEC  L
        CALL FPSUB
        EXX
        JR   SINC


;SINUS.

;SIN(X) beregnes paa flg. maade:
;Hvis ABS(X)>2*PI saa X=FRAC(X/(2*PI))*2*PI
;Hvis X<0 saa X=X+2*PI
;Hvis X>PI saa X=X-PI, fortegn -
;Hvis X>PI/2 saa X=PI-X
;Y=X/3, Z=Y^2
;SIN(Y)=Y(((((Z+K1)Z+K2)Z+K3)Z+K4)Z+K5)/K5
;K1=-110      K2=7920       K3=-332640
;K4=6652800   K5=-39916800
;SIN(X)=4(.75*SIN(Y)-SIN(Y)^3)

SIN:    EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
SINC:   CALL ACPI       ;AC'=2PI
        INC  L
        EXX

        LD   A,L        ;Hvis tallet er mindre
        CP   EXPN-20    ;end 1E-7 saa returner
        JP   C,SIN7

        PUSH BC         ;Er ABS(AC)>2PI
        RES  7,B
        CALL CMP
        POP  BC
        CALL NC,MOD     ;Ja => AC=AC MOD 2PI

SIN1A:  BIT  7,B        ;Hvis AC<0 saa laeg
        JR   Z,SIN2     ;2PI til AC
        CALL FPADD

SIN2:   EXX             ;AC'=PI
        DEC  L
        EXX
        CALL CMP        ;Er AC>PI?
        PUSH AF         ;Gem flag som fortegn
        JR   C,SIN3     ;Nej => SIN3
        CALL FPSUB      ;AC=AC-PI

SIN3:   EXX             ;AC'=PI/2
        DEC  L
        EXX
        CALL CMP        ;Er AC>PI/2?
        JR   C,SIN4     ;Nej => SIN4
        EXX             ;AC=PI-AC
        INC  L
        CALL FPSUB

SIN4:   LD   A,L        ;Hvis tallet er mindre
        CP   EXPN-20    ;end 1E-7 saa returner
        JR   C,SIN7A

        EXX             ;AC=AC/3
        LD   BC,02AAAH
        LD   DE,0AAAAH
        LD   HL,0AA7FH
        CALL FPMUL

        PUSH IX
        LD   IX,SINK-6
        LD   A,5
        CALL COMSER
        POP  IX

        CALL EQUAL      ;Gem i AC'
        CALL FPMUL      ;Udregn SIN(X)^3
        CALL FPMUL
        PUSH BC         ;Gem paa stakken
        PUSH DE
        PUSH HL
        EXX
        CALL EQUAL      ;Udregn .75*SIN(X)
        DEC  L
        DEC  L
        EXX
        DEC  L
        CALL FPADD
        EXX             ;Hent SIN(X)^3
        POP  HL
        POP  DE
        POP  BC
        EXX
        CALL FPSUB      ;Traek det fra
        INC  L          ;Gang med 4
        INC  L

SIN7A:  POP  AF         ;Indsaet fortegn
        INC  L
        DEC  L
        JR   Z,SIN7
        JR   C,SIN7
        LD   A,B
        XOR  SIGN
        LD   B,A
SIN7:   OR   A
        JP   ADD10      ;Hent AC'

;Konstanter for udregning af SINUS.

SINK:   DW 0DC00H,00000H,00087H  ;K1

        DW 07780H,00000H,0008DH  ;K2

        DW 0A26CH,00000H,00093H  ;K3

        DW 04B07H,00000H,00097H  ;K4

        DW 09845H,04000H,0009AH  ;K5



;TITALS LOGARITME.

;LOG(X) beregnes af LN(X)/LN(10).

LOG:    CALL LN
        RET  C
        EXX
        PUSH BC
        PUSH DE
        PUSH HL
        LD   BC,05E5BH  ;1/LN(10)
        LD   DE,0D8A9H
        LD   HL,0367FH
        CALL FPMUL
        JP   ADD10


;NATURLIGE LOGARITME.

;LN(X) beregnes paa flg. maade:
;X=Y*2^N, 1<=Y<2
;Z=Y*SQR(2)/2
;U=(Z-1)/(Z+1), V=U^2
;R=U((((((V+K1)V+K2)V+K3)V+K4)V+K5)V+K6)/K6
;Kn=13/(13-2n)
;LN(X)=2*R+LN(2)/2+N*LN(2)

LN:     INC  L          ;Er AC nul?
        DEC  L
        SCF             ;Indiker fejl
        RET  Z          ;Ja => Returner
        BIT  7,B        ;Negativ?
        RET  NZ         ;Ja => Returner

        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        LD   BC,03504H  ;AC'=SQR(2)/2
        LD   DE,0F333H
        LD   HL,0FB80H
        EXX

        LD   A,L        ;Udregn N
        LD   L,EXPN+1   ;Udregn Y
        SUB  L
        PUSH AF         ;Gem N

        CALL FPMUL      ;Udregn Z
        EXX             ;Udregn U
        CALL AC1
        EXX
        CALL FPSUB
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        INC  L
        CALL FPADD
        EXX
        POP  HL
        POP  DE
        POP  BC
        CALL FPDIV

        PUSH IX         ;Udregn LN(Z)
        LD   IX,LNK-6
        LD   A,6
        CALL COMSER
        POP  IX

        INC  L          ;Laeg LN(2)/2 til
        EXX
        CALL ACLN2
        DEC  L
        EXX
        CALL FPADD
        POP  AF
        PUSH BC         ;Gem resultat
        PUSH DE
        PUSH HL
        LD   L,A        ;Udregn N*LN(2)
        LD   H,0
        JR   NC,LN1
        DEC  H
LN1:    CALL FLOAT
        EXX
        INC  L
        CALL FPMUL
        EXX
        POP  HL         ;Hent resultat
        POP  DE
        POP  BC
        CALL FPADD      ;Adder
        LD   A,L
        CP   EXPN-25    ;LN(X)<3E-8 => LN(X)=0
        CALL C,ZERO
        JP   ADD10      ;Hent AC'

;Konstanter for udregning af LN.

LNK:    DW 01745H,0D174H,05D81H  ;K1

        DW 038E3H,08E38H,0E481H  ;K2

        DW 06DB6H,0DB6DH,0B781H  ;K3

        DW 02666H,06666H,06682H  ;K4

        DW 00AAAH,0AAAAH,0AB83H  ;K5

        DW 05000H,00000H,00084H  ;K6



;POTENSOPLOEFTNING.

;X^Y beregnes af EXP(Y*LN(X)).

PWR:    LD   A,L
        OR   A
        RET  Z
        CALL LN
        RET  C
        CALL FPMUL
        RET  C


;EXPONENTIALFUNKTIONEN.

;Hvis X<0 saa udregnes EXP(X)=1/EXP(-X).
;EXP(X) beregnes paa flg. maade:
;EXP(X)=2^Y, Y=X/LN(2)
;2^Y=2^INT(Y)*2^Z, Z=FRAC(Y)
;2^Z udregnes af:
;2^Z=(((((((Z+K1)*Z+K2)*Z)2+K3)....)*Z+K7)/K7
;K1=6.6042604723   K2=62.027114868
;K3=444.01034843   K4=2563.5667136
;K5=11095.090786   K6=32013.685271
;K7=46185.984492

EXP:    EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        CALL ACLN2      ;AC'=LN(2)
        EXX

        OR   A          ;Gem fortegn
        BIT  7,B
        PUSH AF
        RES  7,B        ;Goer positivt

        CALL FPDIV      ;Udregn Y
        LD   A,L        ;Er Y>128?
        CP   EXPN+8
        JP   NC,EXP4    ;Ja => EXP4

        CALL EQUAL      ;AC'=Y
        CALL FRAC       ;Udregn Z=FRAC(Y)
        EXX             ;Udregn INT(Y)
        CALL FIX
        LD   A,L
        PUSH AF         ;Gem INT(Y)
        EXX

EXP1:   PUSH IX         ;Udregn 2^Z
        LD   IX,EXPK-6
        LD   A,7
        CALL CALCS
        POP  IX

EXP3:   POP  AF         ;Hent 2^INT(Y)
        ADD  A,L        ;Udregn 2^Z*2^INT(Y)
        LD   L,A
        JR   NC,EXP6    ;Ikke overflow => EXP6

EXP4:   POP  AF         ;Juster stakken
        SCF             ;Indiker overflow
EXP5:   JP   ADD10      ;Hent AC'

EXP6:   POP  AF         ;Hent fortegn
        JR   Z,EXP5     ;Positivt => EXP5
        EXX             ;Tag den reciprokke
        CALL AC1
        CALL FPDIV
        JR   EXP5

;Konstanter for udregning af EXP.

EXPK:   DW 05356H,01A0EH,0DE83H  ;K1

        DW 0781BH,0C3FFH,0FB86H  ;K2

        DW 05E01H,05318H,0F189H  ;K3

        DW 02039H,01142H,0418CH  ;K4

        DW 02D5CH,05CF6H,0DF8EH  ;K5

        DW 07A1BH,05EDBH,0CD8FH  ;K6

        DW 03469H,0FC07H,0E590H  ;K7


;ARCCUS TANGENS.

;Hvis X>1 udregnes ATN(X)=PI/2-ATN(1/X).
;Til beregning af ATN(X) bruges:
;Y=X^2, A=PI/24,
;ATN(X)=X(((((Y+K1)*Y+K2)*Y+K3)*Y+K4)*Y+K5)/K5,
;hvor 0<=X<A og
;K1=-11/9  K2=11/7  K3=-11/5  K4=11/3  K5=-11
;X bestemmes til at ligge i et af interv.:
;1. X<TAN(A)
;2. TAN(A)<=X<TAN(3*A)    ,K=2*A
;3. TAN(3*A)<=X<TAN(5*A)  ,K=4*A
;4. X>=TAN(5*A)           ,K=6*A
;Hvis X er i foerste interv. bruges formelen
;alene, men ellers bruges:
;Y=(X-TAN(K))/(1+X*TAN(K))
;ATN(X)=K+ATN(Y)

ATN:    LD   A,L
        OR   A
        RET  Z
        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        PUSH IX
        CALL AC1        ;AC'=1
        EXX
        XOR  A          ;Nulstil flagbyte
        BIT  7,B        ;Er AC positiv?
        JR   Z,ATN1     ;Ja => ATN1

        INC  A          ;Saet negativflag
        RES  7,B        ;AC=ABS(AC)

ATN1:   PUSH AF         ;Gem flag
        CALL CMP        ;Er AC>1
        JR   C,ATN2     ;Ja => ATN2

        EXX             ;AC=1/AC
        CALL FPDIV
        POP  AF         ;Saet reciprokflag
        SET  7,A
        PUSH AF

ATN2:   EXX
        LD   BC,006CFH
        LD   DE,0E98EH
        LD   HL,04A7EH
        EXX
        CALL CMP        ;Er AC<TAN(PI/24)?
        JR   NC,ATN3    ;Nej => ATN3

        CALL ARCTAN     ;Udregn ATN(X)
        JR   ATN6

ATN3:   LD   IX,ATNK-18 ;Peg IX til skalerings-
        LD   A,2        ;konstanter

ATN4:   EX   AF,AF'     ;Gem taeller
        EXX
        LD   DE,18      ;Peg til naeste saet
        ADD  IX,DE
        CALL GETCIX     ;Hent oeverste endepkt.
        EXX
        CALL CMP        ;Er X i dette interval?
        JR   C,ATN5     ;Ja => ATN5
        EX   AF,AF'     ;Hent taeller
        DEC  A          ;Faerdig?
        JR   NZ,ATN4    ;Nej => ATN4

        EXX             ;Juster IX
        LD   DE,12
        ADD  IX,DE
        EXX

ATN5:   EXX
        CALL GTNCIX     ;Hent TAN(K)
        SET  7,B        ;Udregn X-TAN(K)
        CALL FPADD
        PUSH BC         ;Gem resultat
        PUSH DE
        PUSH HL
        CALL GETCIX     ;Hent TAN(K)
        CALL FPMUL      ;Udregn X*TAN(K)
        EXX
        CALL AC1        ;Laeg 1 til
        CALL FPADD
        EXX             ;Gem i AC'
        POP  HL         ;Hent forrige resultat
        POP  DE
        POP  BC
        CALL FPDIV      ;Udregn Y
        PUSH IX         ;Udregn ATN(Y)
        CALL ARCTAN
        POP  IX
        EXX
        CALL GTNCIX     ;Hent K
        CALL FPADD      ;Udregn K+ATN(Y)

ATN6:   POP  AF         ;Hent flagbyte
        RLA             ;Var X>1?
        JR   NC,ATN7    ;Nej => ATN7

        PUSH AF         ;Gem flagbyte
        EXX             ;Udregn PI/2-ATN(X)
        CALL ACPI
        DEC  L
        CALL FPSUB
        POP  AF         ;Hent flagbyte

ATN7:   POP  IX         ;Hent IX
        BIT  1,A        ;Var X<0?
        JR   Z,ATN8     ;Nej => ATN8
        SET  7,B        ;Resultat negativt
ATN8:   OR   A
        JP   ADD10      ;Hent AC'

;Konstanter til skalering af X under beregning
;af ATN.

ATNK:   DW 05413H,0CCCFH,0E77FH  ;TAN(3*A)

        DW 00930H,0A2F4H,0F67FH  ;TAN(2*A)

        DW 0060AH,091C1H,06A7FH  ;2*A

        DW 0446FH,08A9EH,0B580H  ;TAN(5*A)

        DW 013CDH,03A2CH,08280H  ;TAN(4*A)

        DW 0060AH,091C1H,06A80H  ;4*A

        DW 00000H,00000H,00081H  ;TAN(6*A)

        DW 0490FH,0DAA2H,02180H  ;6*A


;Konstanter for beregning af ATN.

ARCTK:  DW 09C71H,0C71CH,07281H  ;K1

        DW 04924H,09249H,02581H  ;K2

        DW 08CCCH,0CCCCH,0CD82H  ;K3

        DW 06AAAH,0AAAAH,0AB82H  ;K4

        DW 0B000H,00000H,00084H  ;K5


;Udregn taylorraekken for ARCCUS TANGENS.

ARCTAN: LD   IX,ARCTK-6
        LD   A,5

;COMSER udregner en potensraekke af formen:
;T=X*((((X^2+K1)*X^2+K2)....)*X^2+Kn)/Kn,
;hvor X er i AC, n er i A, og adressen paa
;konstanterne (minus 6) i IX.

COMSER: PUSH BC         ;Gem X
        PUSH DE
        PUSH HL
        PUSH AF         ;Gem laengde
        CALL EQUAL      ;Udregn Z=X^2
        CALL FPMUL
        POP  AF         ;Hent laengde
        CALL CALCS      ;Udregn raekken
        EXX             ;Hent X
        POP  HL
        POP  DE
        POP  BC
        JP   FPMUL      ;Gang med X

;CALCS udregner en potensraekke af formen:
;U=(((((Z+K1)*Z+K2)*Z+K3)....)*Z+Kn)/Kn,
;hvor Z er i AC, n er i A, og adressen paa
;konstanterne (minus 6) i IX.

CALCS:  EXX             ;Gem Z i AC'
        CALL AC1        ;Start med resultat=1
CALC1:  PUSH AF         ;Gang med Z
        CALL FPMUL
        POP  AF
        PUSH AF
        EXX
        PUSH BC         ;Gem Z
        PUSH DE
        PUSH HL
        CALL GTNCIX     ;Hent naeste konstant
        CALL FPADD      ;Laeg til resultat
        EXX             ;Hent Z
        POP  HL
        POP  DE
        POP  BC
        EXX
        POP  AF         ;Faerdig?
        DEC  A
        JR   NZ,CALC1   ;Nej => CALC1
        EXX
        CALL GETCIX
        EXX
        JP   FPDIV

;Saet AC lig den konstant IX peger paa.

GTNCIX: LD   DE,6
        ADD  IX,DE
GETCIX: LD   C,(IX+0)
        LD   B,(IX+1)
        LD   E,(IX+2)
        LD   D,(IX+3)
        LD   L,(IX+4)
        LD   H,(IX+5)
        RET

;Saet AC lig 2*PI.

ACPI:   LD   BC,0490FH
        LD   DE,0DAA2H
        LD   HL,02182H
        RET

;Saet AC lig LN(2).

ACLN2:  LD   BC,03172H
        LD   DE,017F7H
        LD   HL,0D280H
        RET

;FLOATING POINT EQUAL.

EQUAL:  PUSH BC
        PUSH DE
        PUSH HL
        EXX
        POP  HL
        POP  DE
        POP  BC
        RET

;FLOATING POINT TIL 16-BIT INTEGER MED
;2'S COMPLEMENT FORTEGN.

FIX:    OR   A
        BIT  7,L        ;Exponent<0?
        JR   Z,FIX4     ;Ja => FIX4
        BIT  7,B        ;Gem fortegn
        EX   AF,AF'
        SET  7,B        ;Saet MSB

FIX1:   LD   A,EXPN+15  ;Test exponent
        CP   L
        RET  C          ;EXP>15 => overflow
        JR   Z,FIX2     ;EXP=15 => FIX2
        CALL SRIGHT     ;EXP<15 => roter til
        INC  L          ;hoejre og laeg 1 til
        JR   FIX1       ;exponent

FIX2:   CALL SRIGHT     ;Roter til hoejre
        EX   AF,AF'     ;Negativt fortegn?
        JR   Z,FIX3     ;Nej => INT2
        LD   HL,0       ;Tag 2's complement
        SBC  HL,BC
        OR   A          ;Nulstil carry
        RET

FIX3:   LD   H,B        ;Hent tallet
        LD   L,C
        RET

FIX4:   LD   HL,0       ;Underflow
        RET

;16-BIT INTEGER MED 2'S COMPLEMENT FORTEGN
;TIL FLOATING POINT.

FLOAT:  LD   A,H        ;Er HL=0?
        OR   L
        JP   Z,ZERO     ;Ja => ZERO

        BIT  7,H        ;Er HL negativ?
        JR   Z,FLT1     ;Nej => FLT1

        EX   DE,HL      ;Tag 2's complement
        LD   HL,0
        OR   A
        SBC  HL,DE

FLT1:   EX   AF,AF'     ;Gem fortegn i F'
        LD   B,H        ;Saet mantissa
        LD   C,L
        LD   DE,0
        LD   HL,EXPN+16 ;Saet exponent

FLT2:   BIT  7,B        ;Normaliser
        JR   NZ,FLT3
        CALL SLEFT
        DEC  L
        JR   FLT2

FLT3:   EX   AF,AF'     ;Negativt?
        RET  C          ;Ja => Retur
        RES  7,B        ;Positivt
        RET


;FLYDENDE TAL TIL TEKSTSTRENG.

;Resultatet afleveres i den buffer IX peger
;paa, og er afsluttet med et 0.
;Udskriftens format afgoeres af H' og L'.

;Register L':

;Bit 0    Udskriftstype
;           0 - Fastkomma notation
;           1 - Exponentiel notation
;Bit 2-1  Fortegnsformat
;           00 - Intet fortegn
;           01 - AC>=0: Intet fortegn
;                AC<0:  "-"
;           10 - AC>=0: " "
;                AC<0:  "-"
;           11 - AC>=0: "+"
;                AC<0:  "-"
;Bit 3    Decimaldelsformat
;           0 - Kun betydende cifre
;           1 - Skriv alle cifre
;Bit 4    Heltalsdelformat
;           0 - Kun betydende cifre
;           1 - Blanktegn foer betydende cifre

;Register H':

;Bit 3-0  Decimalfeltets laengde (0-15)
;Bit 7-4  Heltalsfeltets laengde (1-15)
;         Bruges kun hvis bit 0 i L' er 0


FSTRR:  EXX
        LD   A,L        ;Gem format i A og A'
        EX   AF,AF'
        LD   A,H
        EXX
        JR   OUTN1

;FLYDENDE TAL TIL TEKSTSTRENG.

;Formatet efterfoelger kaldet som to bytes, der
;har samme betydning som L' henholdsvis H' ved
;kald af FSTRR.

FSTRS:  EX   (SP),IX
        LD   A,(IX+0)    ;Gem format i A og A'
        INC  IX
        EX   AF,AF'
        LD   A,(IX+0)
        INC  IX
        EX   (SP),IX

OUTN1:  PUSH IX         ;Gem IX,IY,AC,AC'
        PUSH IY
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        LD   IY,-13     ;Opret en 13 bytes
        ADD  IY,SP      ;buffer paa stakken
        LD   SP,IY
        EXX
        LD   E,A        ;Gem formatet
        EX   AF,AF'
        LD   D,A
        PUSH DE
        EXX

        INC  L          ;Er AC nul?
        DEC  L
        JR   NZ,DIGITS  ;Nej => DIGITS

        POP  DE         ;Hent formatet
DZERO:  LD   (IY+0),L   ;Marker bufferslut
        JP   OUTM

DIGITS: PUSH BC         ;Gem BC
        RES  7,B        ;Goer AC positiv
        LD   A,L        ;Hent exponent
        EXX

;Udregn titalsexponenten udfra totalsexponenten
;paa foelgende maade:
;E10=INT(E2*LOG(2))=INT((E2*77+5)/256)

        LD   H,0        ;HL=toexponent
        SUB  EXPN
        JR   NC,SC1
        DEC  H
SC1:    LD   L,A
        PUSH HL         ;HL=HL*77+5
        ADD  HL,HL
        ADD  HL,HL
        PUSH HL
        ADD  HL,HL
        LD   D,H
        LD   E,L
        ADD  HL,HL
        ADD  HL,HL
        ADD  HL,HL
        ADD  HL,DE
        POP  DE
        ADD  HL,DE
        POP  DE
        ADD  HL,DE
        LD   DE,5
        ADD  HL,DE
        LD   A,H        ;A=INT(HL/256)
        CP   -39
        JR   NZ,SC2
        INC  A
SC2:    LD   (IY+0),A   ;Gem tiexponent
        NEG             ;Multiplicer AC med
        CALL TENF       ;10^-tiexponent
        LD   A,L        ;Er AC<1?
        CP   EXPN+1
        JR   NC,SC3     ;Nej => SC3
        DEC  (IY+0)     ;Tiexponent-1
        CALL MUL10      ;AC=AC*10

SC3:    SET  7,B
        LD   A,EXPN+4
        SUB  L
        LD   L,0
        JR   Z,DIGI1
SC4:    CALL SRIGHT
        RR   L
        DEC  A
        JR   NZ,SC4

DIGI1:  LD   A,(IY+0)   ;Hent tiexp.
        LD   (IY+0),0   ;Marker bufferstart
        PUSH IY         ;Gem IY
        PUSH AF         ;Gem tiexp.
        LD   A,12       ;Udregn 12 cifre

DIGI2:  EX   AF,AF'     ;Gem taeller
        LD   A,B
        RRA
        RRA
        RRA
        RRA
        AND  0FH
        ADD  A,'0'
        INC  IY
        LD   (IY+0),A
        LD   A,B
        AND  0FH
        LD   B,A

        PUSH BC         ;Gang AC med 10
        PUSH DE
        PUSH HL
        SLA  L
        CALL LEFT
        SLA  L
        CALL LEFT
        EX   DE,HL
        EX   (SP),HL
        ADD  HL,DE
        POP  DE
        EX   (SP),HL
        ADC  HL,DE
        EX   DE,HL
        POP  HL
        EX   (SP),HL
        ADC  HL,BC
        LD   B,H
        LD   C,L
        POP  HL
        SLA  L
        CALL LEFT

        EX   AF,AF'     ;Hent taeller
        DEC  A          ;Faerdig?
        JR   NZ,DIGI2   ;Nej => DIGI2

        POP  AF         ;Hent tiexp.
        POP  IY         ;Hent IY,BC
        POP  BC
        INC  IY         ;Peg til foerste ciffer
        LD   C,A        ;Gem titalsexp. i C

ROUND:  POP  DE         ;Hent format
        LD   A,E        ;Udregn nummeret paa
        AND  FWIDTH     ;det ciffer der skal
        INC  A          ;afrundes fra
        BIT  0,D
        JR   NZ,ROU1
        ADD  A,C
        JP   M,DZERO    ;Neg. => Udskriv 0

ROU1:   CP   12         ;Max. nummer 11
        JR   C,ROU2
        LD   A,11

ROU2:   PUSH IY         ;Udregn adressen paa
        POP  HL         ;det ciffer der skal
        ADD  A,L        ;afrundes
        LD   L,A
        JR   NC,ROU3
        INC  H

ROU3:   LD   A,(HL)     ;Hent ciffer
        LD   (HL),0     ;Marker bufferslut
        CP   '5'        ;Afrunding?
        JR   C,ROU5     ;Nej => ROU5

ROU4:   DEC  HL         ;Tag forrige ciffer
        LD   A,(HL)
        OR   A          ;Bufferstart?
        JR   Z,ROU6     ;Ja => ROU6
        INC  A          ;Laeg 1 til ciffer
        LD   (HL),A
        CP   '9'+1      ;Var ciffer '9'?
        JR   C,OUTM     ;Nej => OUTM
        LD   (HL),0     ;Marker bufferslut
        JR   ROU4

ROU5:   DEC  HL         ;Tag forrige ciffer
        LD   A,(HL)
        SUB  '0'        ;Er det '0'?
        JR   NZ,OUTM    ;Nej => OUTM
        LD   (HL),A     ;Marker bufferslut
        JR   ROU5

ROU6:   INC  HL         ;Tallet var 9999...
        LD   (HL),'1'   ;Lav om til 10000...
        INC  HL
        LD   (HL),0
        INC  C          ;Laeg 1 til tiexp.

OUTM:   LD   A,(IY+0)   ;Er tallet 0?
        OR   A
        JR   NZ,OM1     ;Nej => OM1
        LD   B,A        ;Positivt fortegn
        LD   C,A        ;Tiexp = 0

OM1:    BIT  0,D        ;Exponentielt?
        JR   NZ,OM6     ;Ja => OM6

        LD   A,E        ;Udregn det antal
        AND  IWIDTH     ;blanktegn der skal
        RRCA            ;udskrives inden tallet
        RRCA
        RRCA
        RRCA
        DEC  A
        BIT  2,D
        JR   NZ,OM2
        BIT  1,D
        JR   Z,OM3
        BIT  7,B
        JR   Z,OM3
OM2:    DEC  A
OM3:    BIT  7,C
        JR   NZ,OM4
        SUB  C
OM4:    OR   A          ;Negativt?
        SCF             ;Indiker fejl
        JP   M,POPALL   ;Ja => POPALL

        BIT  4,D        ;Blanktegn?
        JR   Z,OM6      ;Nej => OM6

        LD   H,A        ;Gem blanktegn
        INC  H
OM5:    DEC  H
        JR   Z,OM6
        LD   A,' '
        CALL STOA
        JR   OM5

OM6:    BIT  7,B        ;Gem fortegn
        JR   Z,OM7
        LD   A,'-'
        BIT  2,D
        JR   NZ,OM8
        BIT  1,D
        JR   NZ,OM8
        JR   OM9
OM7:    BIT  2,D
        JR   Z,OM9
        LD   A,' '
        BIT  1,D
        JR   Z,OM8
        LD   A,'+'
OM8:    CALL STOA

OM9:    BIT  0,D        ;Exponentielt?
        JR   Z,OM10     ;Nej => OM10
        LD   H,C        ;Gem tiexp. i H
        LD   C,0        ;tiexp. = 0

OM10:   BIT  7,C        ;Er tiexp.>=0?
        JR   Z,OM11     ;Ja => OM11

        CALL STOZ       ;Gem '0'
        JR   OM12

OM11:   CALL STODIG     ;Gem de cifre der
        DEC  C          ;staar foer kommaet
        JP   P,OM11

OM12:   LD   A,E        ;Skal der cifre efter
        AND  FWIDTH     ;kommaet?
        JR   Z,OM15     ;Nej => OM15
        LD   E,A
        CALL MORED      ;Er der flere cifre?
        JR   Z,OM15     ;Nej => OM15

        LD   A,'.'      ;Gem '.'
        CALL STOA

OM13:   INC  C          ;Gem ubetydende nuller
        JR   Z,OM14
        CALL STOZ
        DEC  E
        JR   NZ,OM13

OM14:   DEC  E          ;Gem betydende cifre
        JP   M,OM15
        CALL STODIG
        CALL MORED
        JR   NZ,OM14

OM15:   BIT  0,D        ;Exponentielt?
        JR   Z,POPA1    ;Nej => POPA1

        LD   A,'E'      ;Gem 'E'
        CALL STOA
        LD   A,'+'      ;Gem fortegn
        BIT  7,H
        JR   Z,OEX1
        LD   A,H
        NEG
        LD   H,A
        LD   A,'-'
OEX1:   CALL STOA
        LD   A,H        ;Udregn 2-cifret exp.
        LD   B,'0'-1
OEX2:   INC  B
        SUB  10
        JR   NC,OEX2
        ADD  A,10+'0'
        LD   (IX+0),B   ;Gem exponent
        INC  IX
        CALL STOA

POPA1:  OR   A          ;Nulstil carry
POPALL: EX   AF,AF'     ;Gem status
        LD   (IX+0),0   ;Marker bufferslut
        LD   HL,13      ;Fjern talbuffer
        ADD  HL,SP
        LD   SP,HL
        POP  HL         ;Hent AC',AC,IY,IX
        POP  DE
        POP  BC
        EXX
        POP  HL
        POP  DE
        POP  BC
        POP  IY
        POP  IX
        EX   AF,AF'     ;Hent status
        RET

;Gem et ciffer i bufferen.

STODIG: LD   A,(IY+0)   ;Hent ciffer
        INC  IY
        OR   A          ;Bufferslut?
        JR   NZ,STOA    ;Nej => STOA
        DEC  IY         ;Juster
STOZ:   LD   A,'0'      ;Gem '0'
STOA:   LD   (IX+0),A
        INC  IX
        RET

;Undersoeg om der er flere cifre.

MORED:  BIT  3,D
        RET  NZ
        LD   A,(IY+0)
        OR   A
        RET

;Multiplicer AC med 10^A.

TENF:   PUSH AF         ;Gem AF
        OR   A          ;Positiv exponent?
        JP   P,TF1      ;Ja => TF1
        NEG             ;A=ABS(A)
TF1:    PUSH AF         ;Gem flag
        SRL  A          ;A=INT(A/4)
        SRL  A
        LD   HL,-6      ;Udregn offset til
        LD   DE,6       ;konstant nummer A
        INC  A
TF2:    ADD  HL,DE
        DEC  A
        JR   NZ,TF2
        EX   DE,HL
        PUSH IX         ;Gem IX
        LD   IX,CON10   ;Hent konstant
        ADD  IX,DE
        CALL GETCIX
        POP  IX         ;Hent IX
        POP  AF         ;Hent exponent
        AND  3          ;Juster faktor
TF3:    JR   Z,TF4
        PUSH AF
        CALL MUL10
        POP  AF
        DEC  A
        JR   TF3
TF4:    POP  AF         ;Hent exponent
        OR   A          ;Positiv?
        JP   P,FPMUL    ;Ja => Multipicer
        EXX             ;Nej => Divider
        JP   FPDIV

;Tier potens konstanter for konvertering.

CON10:  DW 00000H,00000H,00081H ;1E+00

        DW 01C40H,00000H,0008EH ;1E+04

        DW 03EBCH,02000H,0009BH ;1E+08

        DW 0684DH,0A510H,000A8H ;1E+12

        DW 00E1BH,0C9BFH,004B6H ;1E+16

        DW 02D78H,0EBC5H,0ACC3H ;1E+20

        DW 053C2H,01BCEH,0CDD0H ;1E+24

        DW 0013FH,03978H,0F9DEH ;1E+28

        DW 01DC5H,0ADA8H,02BEBH ;1E+32

        DW 04097H,0CE7BH,0C9F8H ;1E+36



;AC=ABS(AC)*10.

MUL10:  LD   A,L
        OR   A
        RET  Z
        SET  7,B
        PUSH BC
        PUSH DE
        LD   A,H
        CALL SRIGHT
        CALL SRIGHT
        ADD  A,H
        LD   H,A
        EX   (SP),HL
        ADC  HL,DE
        EX   DE,HL
        POP  HL
        EX   (SP),HL
        ADC  HL,BC
        LD   B,H
        LD   C,L
        POP  HL
        JR   NC,M10A
        CALL RIGHT
        INC  L
        SCF
        RET  Z
M10A:   LD   A,L
        ADD  A,3
        LD   L,A
        RES  7,B
        RET

;ASCII TIL FLOATING POINT.

CNVN:   EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        LD   BC,0       ;Nulstil flag
        EXX
        CALL ZERO       ;Nulstil AC

        LD   A,(IX+0)   ;Hent foerste karakter
        CP   '+'        ;Plus?
        JR   Z,CNV1     ;Ja => CNV1
        DEC  IX
        CP   '-'        ;Minus?
        JR   NZ,CNV1    ;Nej => CNV1
        EXX             ;Saet minusflag
        SET  7,B
        EXX
        INC  IX

CNV1:   INC  IX         ;Hent naeste karakter
        LD   A,(IX+0)

        CP   '.'        ;Decimalpunkt?
        JR   NZ,CNV2    ;Nej => CNV2
        EXX             ;Er det det foerste?
        BIT  6,B
        SCF
        JP   NZ,CNV6    ;Nej => FEJL
        SET  6,B        ;Ja => saet flag
        EXX
        JR   CNV1

CNV2:   CP   'E'        ;Exponentnotation?
        JR   Z,CNV4     ;Ja => CNV4

        CALL DIGTST     ;Er det et ciffer?
        JR   NC,CNV5    ;Nej => CNV5

        EX   AF,AF'     ;Gang resultat med 10
        CALL MUL10
        JR   C,CNV6A
        EX   AF,AF'
        EXX             ;Laeg det nye ciffer
        PUSH BC         ;til
        LD   L,A
        LD   H,0
        CALL FLOAT
        CALL FPADD
        EXX
        POP  BC
        JR   C,CNV6A
        BIT  6,B        ;Er decimalflag sat?
        JR   Z,CNV3     ;Nej => CNV3
        DEC  C          ;Traek 1 fra tiexp.
CNV3:   EXX
        JR   CNV1

CNV4:   CALL MFACT      ;Gang med titalsfaktor
        JR   C,CNV6     ;Overflow => CNV6
        EXX
        INC  IX         ;Hent naeste karakter
        LD   A,(IX+0)
        CP   '+'        ;Plus?
        JR   Z,CNV4A    ;Ja => CNV4A
        CP   '-'        ;Minus?
        JR   NZ,CNV4B   ;Nej => CNV4B
        SET  5,B        ;Saet minusflag
CNV4A:  INC  IX

CNV4B:  CALL GDTST      ;Er der et ciffer?
        CCF             ;Saet carry hvis ikke
CNV6A:  JR   C,CNV6     ;Nej => CNV6
        LD   C,A        ;Gem i C
        INC  IX         ;Er der et mere?
        CALL GDTST
        JR   NC,CNV4C   ;Nej => CNV4C

        INC  IX         ;Gang forrige ciffer
        LD   D,A        ;med 10 og laeg det
        LD   A,C        ;nye til
        ADD  A,A
        ADD  A,A
        ADD  A,C
        ADD  A,A
        ADD  A,D
        LD   C,A

CNV4C:  BIT  5,B        ;Negativt?
        JR   Z,CNV4D    ;Nej => CNV4D
        LD   A,C
        NEG
        LD   C,A
CNV4D:  EXX

CNV5:   CALL MFACT      ;Gang med titalsfaktor
        JR   C,CNV6     ;Overflow => CNV6
        EXX             ;Negativt?
        BIT  7,B
        EXX
        JR   Z,CNV6     ;Nej => CNV6
        SET  7,B        ;Saet minusflag i AC

CNV6:   JP   ADD10      ;Hent AC'

;Gang tallet i AC med 10^C'

MFACT:  EXX
        LD   A,C
        ADD  A,EXPN
        CP   -37+EXPN   ;Tiexp.<-37?
        RET  C          ;Ja => Retur
        CP   38+EXPN    ;Tiexp.>37?
        CCF
        RET  C          ;Ja => Retur

        PUSH BC         ;Gem BC
        LD   A,C        ;Hent tiexponent
        CALL TENF       ;Mul. med 10^tiexp.
        EXX             ;Hent BC
        POP  BC
        EXX
        RET

;Saet carry hvis karakteren i A er et ciffer.

GDTST:  LD   A,(IX+0)
DIGTST: SUB  '0'
        CCF
        RET  NC
        CP   10
        RET

;Saet AC lig 1.

AC1:    LD   BC,00000H
        LD   DE,00000H
        LD   HL,00081H
        RET
;------------END OF MATH48------------

.macro __constfp %xx,%yy,%zz
        ld      bc,%xx
        ld      de,%yy
        ld      hl,%zz
.endm

.macro constfp %x
        ld      hl,%x
        call    __atof
.endm

.macro pushfp
        push    bc
        push    de
        push    hl
.endm

.macro popfp
        pop     hl
        pop     de
        pop     bc
.endm

; Load FP at address HL into BCDEHL
__loadfp:
        push    ix
        push    hl
        pop     ix
        ld      l,(ix+0)
        ld      h,(ix+1)
        ld      e,(ix+2)
        ld      d,(ix+3)
        ld      c,(ix+4)
        ld      b,(ix+5)
        pop     ix
        ret

; Store FP into BCDEHL into address HL
__storefp:
        push    ix
        push    hl
        pop     ix
        exx
        ld      (ix+0),l
        ld      (ix+1),h
        ld      (ix+2),e
        ld      (ix+3),d
        ld      (ix+4),c
        ld      (ix+5),b
        pop     ix
        ret

__flteq:
        call    CMP
        jr      z,__flteq1
__flteq0:
        ld      de,0
        ret
__flteq1:
        ld      de,1
        ret

__fltneq:
        call    CMP
        jr      nz,__fltneq1
__fltneq0:
        ld      de,0
        ret
__fltneq1:
        ld      de,1
        ret

__fltlt:
        call    CMP
        jr      c,__fltlt1
__fltlt0:
        ld      de,0
        ret
__fltlt1:
        ld      de,1
        ret

__fltleq:
        call    CMP
        jr      c,__fltleq1
        jr      z,__fltleq1
__fltleq0:
        ld      de,0
        ret
__fltleq1:
        ld      de,1
        ret

__fltpwr2:
        call    EQUAL
        call    FPMUL
        ret

__atof:
        push    ix
        ld      de,hl
        ld      ix,de
        inc     ix
        call    CNVN
        pop     ix
        ret

__ftoa:
        push    ix
        ld      ix,__ftoatmp + 1
        call    FSTRR
        jr      nc,__ftoaok
        ld      hl,__ftoaerr
        pop     ix
        ret
__ftoaok:
        ld      ix,__ftoatmp
        ld      b,255
__ftoalp:
        inc     ix
        inc     b
        ld      a,(ix)
        cp      0
        jr      nz, __ftoalp
        ld      a,b
        ld      (__ftoatmp),a
        ld      hl,__ftoatmp
        pop     ix
        ret
__ftoatmp:
        db 31,  "                                "
__ftoaerr:
        db      5,"ERROR"

__putf:
        exx
        ld      hl,$090d
        exx
        call __ftoa
        call __puts
        ret

__putf_exp:
        exx
        push    bc
        ld      a,c
        cp      $09
        jr      nc,__putf_exp_0
        ld      a,1
        jr      __putf_exp_1
__putf_exp_0:             
        sub     $07
        cp      $0a
        jp      c,__putf_exp_1
        
        ld      a,$09
__putf_exp_1:             
        ld      h,a
        ld      l,$0d
        exx
        call    __ftoa
        pop     bc
        call    __puts_fmt
        ret

__putf_fix:
        exx
        push    de
        ld      a,c
;        cp      $10
;        jp      c,__putf_fix_1
;        ld      a,$0f
__putf_fix_1:
        or      $f0
        ld      h,a
        ld      l,$0a
        exx
        call    __ftoa
        pop     bc
        call    __puts_fmt
        ret

; ========================================================================
; Set support
; ========================================================================

;
; Set membership test
;
; Entry: (SP+2) 32 bytes set, (SP+34) 1 byte element
; Exit:  DE=1 if element in set, 0 otherwise
; Uses:  AF, HL, DE
;
__setin_new:
        ld      hl,34
        ld      d,h
        add     hl,sp       ; HL = sp+32
        ld      e,(hl)
        db      $ed,$94 ; pixelad
        db      $ed,$95 ; setae
        db      $ed,$24 ; mirror
        db      $ed,$34,$00,$c0; add hl,-$4000+2
        add     hl,sp       ; HL = sp+32+bit_offset
        ld      e,d         ; DE = 0 when bit is clear
        and     (hl)
        ret     z
        ld      e,1         ; DE = 1 when bit is set
        ret

; Set index to offset
; Entry E index
; Exit DE offset of byte (D always 0), A correct bit set
__setoff:
        ld      e,a
        srl     e
        srl     e
        srl     e
;        inc     e
;        inc     e
        ld      d,a
        ld      a,1
        bit     0,d
        jr      z,__setoff1
        sla     a
__setoff1:
        bit     1,d
        jr      z,__setoff2
        sla     a
        sla     a
__setoff2:
        bit     2,d
        jr      z,__setoff3
        sla     a
        sla     a
        sla     a
        sla     a
__setoff3:
        ld      d,0
        ret

;
; Set membership test
;
; Entry: (SP+2) 32 bytes set, (SP+34) 1 byte element
; Exit:  DE=1 if element in set, 0 otherwise
; Uses:  AF, HL, DE, BC
;
__setmember:
        ld      hl,34
        add     hl,sp
        ld      a,(hl)
        call    __setoff
        ld      hl,2
        add     hl,de
        ld      de,0
        add     hl,sp
        and     (hl)
        ret     z
        ld      de,1
        ret

__setinclude:
        ld      a,e
        call    __setoff
        add     hl,de
        or      (hl)
        ld      (hl),a
        ret

__setexclude:
        ld      a,e
        call    __setoff
        add     hl,de
        xor     255
        and     (hl)
        ld      (hl),a
        ret

;
; Superset of two sets
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  Result in set 2, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setadd:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__setadd1:
        ld      a,(de)
        or      (hl)
        ld      (hl),a
        inc     hl
        inc     de
        djnz    __setadd1
        ret

;
; Difference of two sets
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  Result in set 1, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setsub:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__setsub1:
        ld      a,(de)
        xor     255
        and     (hl)
        ld      (hl),a
        inc     hl
        inc     de
        djnz    __setsub1
        ret

;
; Intersection of two sets
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  Result in set 1, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setmul:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__setmul1:
        ld      a,(de)
        and     (hl)
        ld      (hl),a
        inc     hl
        inc     de
        djnz    __setmul1
        ret

;
; Set equality test (i.e. set 1 = set 2)
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  DE=1 if equal, 0 otherwise, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__seteq:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__seteq1:
        ld      a,(de)
        cp      (hl)
        jr      nz,__seteq2
        inc     hl
        inc     de
        djnz    __seteq1
        ld      de,1
        ret
__seteq2:
        ld      de,0
        ret

;
; Subset-or-equal test (i.e. set 1 <= set 2)
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  DE=1 if set 1 <= set 2, 0 otherwise, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setleq:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__setleq1:
        ld      a,(de)
        ld      c,a
        or      (hl)
        cp      c
        jr      nz,__setleq2
        inc     hl
        inc     de
        djnz    __setleq1
        ld      de,1
        ret
__setleq2:
        ld      de,0
        ret

;
; Superset-or-equal test (i.e. set 1 >= set 2)
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  DE=1 if set 1 >= set 2, 0 otherwise, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setgeq:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ex      de,hl           ; Swap arguments
        ld      b,c
        jr      __setleq1       ; Let __setleq do the actual work

; +  ... a := a or b
; -  ... a := a and not b
; *  ... a := a and b

; =  ... a = b
; >= ... a or b = a 
; <= ... a or b = b

; Include shared with in
; Exclude shared with in
                

;
; Print character to screen
;
; Entry:  A (ASCII code)
; Exit:   -
; Uses:   C,E,IY
;
#if defined(CPM)
__putc:
                ld      e,a
                ld      c,2
                call    5
                ret
#endif

#if defined(NXT)
__putc:
                ld      iy,(__saved_iy)
                rst     16
                ret
#endif

;
; Print string to screen
;
; Entry:  HL (string address)
; Exit:   -
; Uses:   AF,BC
;
__puts:         ld      b,(hl)
                inc     b
                jr      __putschk
__putsloop:     ld      a,(hl)
                push    hl
                push    bc
                call    __putc
                pop     bc
                pop     hl
__putschk:      inc     hl
                djnz    __putsloop
                ret

;
; New line
;
; Entry:  -
; Exit:   -
; Uses:   -
;
__newline:
                ld      a,13
                call    __putc
#if defined(CPM)
                ld      a,10
                call    __putc
#endif
                ret

;
; Print number to screen
;
; Entry:  HL (number)
; Exit:   -
; Uses:   AF,BC,DE
;
__strn:         ex      de,hl
                push    hl
                push    af
                ld      hl,__buffer+1
                call    __itoa
                ld      hl,__buffer
                ld      (hl),a
                pop     af
                pop     de
                call    __movestr
                ret

__strn_fmt:
                push    de
                ld      b,a
                push    bc
                call    __strn
                pop     de
                pop     hl
                call    __ralign
                ret

__strc:
                and     a
                ret     z
                ex      de,hl
                ld      (hl),1
                inc     hl
                ld      (hl),e
                ret

__strs:
                ld      hl,2
                add     hl,sp
                call    __movestr
                pop     de
                ld      hl,256
                add     hl,sp
                ld      sp,hl
                push    de
                ret

__strf:
                push    af
                exx
                push    de
                ld      hl,$090d
                exx
                call    __ftoa
                pop     de
                pop     af
                call    __movestr
                ret

__strf2:
        exx
        push    de
        ld      a,c
;        cp      $10
;        jp      c,__putf_fix_1
;        ld      a,$0f
__str_fix_1:
        or      $f0
        ld      h,a
        ld      l,$0a
        exx
        call    __ftoa
        pop     bc
        call    __puts_fmt
        ret

                push    af
                exx
                push    de
                ld      l,$09
                ld      h,c
                set     4,h
                exx
                call    __ftoa
                pop     de
                pop     af
                call    __movestr
                ret

__stre:
                add     hl,bc
                add     hl,bc
                ld      b,(hl)
                inc     hl
                ld      h,(hl)
                ld      l,b
                call    __movestr
                ret

;
; Right-align Pascal string, inserting spaces at the start.
;
; Pre:
;       HL: string address
;       D : maximum string length
;       E : desired string length
; Post:
;       AF / BC / DE / HL changed
;
__ralign:
        ld      a,d
        cp      e               ; Is desired length > maximum length?
        jp      nc,__ralign1
        ld      e,d

__ralign1:
        ld      a,(hl)
        cp      e               ; Do we already have desired length?
        ret     nc

        ld      b,0
        ld      c,a
        ld      a,e
        sub     (hl)
        ld      (hl),e          ; Set new length

        inc     hl
        add     hl,bc           ; Old end of string
        ld      e,a
        ld      d,0
        push    hl
        add     hl,de           ; New end of string
        ex      de,hl
        pop     hl
        inc     bc
        lddr                    ; Move string

        inc     hl
        ld      b,a
        ld      a,32

__ralign2:
        ld      (hl),a          ; Fill with spaces
        inc     hl
        djnz    __ralign2

        ret





;
; Print number to screen
;
; Entry:  HL (number)
; Exit:   -
; Uses:   AF,BC,DE
;
__putn:         ex      hl,de
                ld      hl,__buffer+1
                call    __itoa
                ld      hl,__buffer
                ld      (hl),a
                call    __puts
                ret

;
; Print enum to screen
;
; Entry:  HL (value), DE (literal table)
; Exit:   -
; Uses:   AF,BC,DE
;
__pute:
                add     hl,hl
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                jp      __puts

;
; Formatted output. Similar to normal output, but BC contains field width.
;
__putc_fmt:
                ld      a,l
                ld      hl,__buffer+1
                ld      (hl),a
                dec     hl
                ld      (hl),1
                jp      __puts_fmt

__puts_fmt:
                push    hl
                ld      a,c
                sub     (hl)
                jr      z,__puts_fmt_1
                jr      c,__puts_fmt_1
                ld      b,a
__puts_fmt_loop:
                push    bc
                ld      a, ' '
                call    __putc
                pop     bc
                djnz    __puts_fmt_loop
__puts_fmt_1:
                pop     hl
                jp      __puts

__putn_fmt:     push    bc
                ex      hl,de
                ld      hl,__buffer+1
                call    __itoa
                ld      hl,__buffer
                ld      (hl),a
                pop     bc
                jp      __puts_fmt

__pute_fmt:
                add     hl,hl
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                jp      __puts_fmt

;
; Read number from keyboard
;
; Entry:  -
; Exit:   HL
; Uses:   AF,BC,DE
;
; TODO Separate input from string-to-integer functionality
;
#if defined(CPM)
__getn:         ld      a,'>'
                call    __putc
                ld      hl,6
                ld      (__buffer),hl
                ld      de,__buffer
                ld      c,10
                call    5
                ld      a,'>'
                call    __putc
                ld      hl,__buffer+1
                call    __puts
                ld      hl,__buffer+1
                ld      a,(hl)
                inc     hl
                call    __atoi
                ret
#endif

#if defined(NXT)
__getn:
                push    ix
                ld      iy, (__saved_iy)
                ;    ld      a,1
                ;   rst $18
                ;   defw    $1601
                ld a,'>'
                call __putc
                ld      de,(23633)      ; save current channel
                push    de       
                ld      de,(__win_handle)        ; set current channel to magic window
                ld      (23633), de 
                ld      de,$01c3
                ld      c,7
                exx
                ld      hl,__buffer
                ld      e,0
                ld      a,10
                exx
                rst     8
                db      $94
                pop     bc
                ld      (23633), bc 
                pop ix
                push    de
                pop de
                ld      a,e
                ld      hl,__buffer
                call    __atoi
                ret
#endif

;
; Print assertion failed message
;
; Entry:  HL Source file
;         DE Source line
;         BC Value
; Exit:   -
; Uses:   ?
;
__assert:
                ld      a,c
                and     a
                jr      z,__assert1
                ld      hl,(__assertpassed);
                inc     hl
                ld      (__assertpassed), hl
                ret
__assert1:      push    de
                push    hl
                ld      hl, __assert_msg_1
                call    __puts
                pop     hl
                call    __puts
                ld      hl, __assert_msg_2
                call    __puts
                pop     hl
                call    __putn
                call    __newline
                ld      hl,(__assertfailed)
                inc     hl
                ld      (__assertfailed), hl
                ret
__assert_msg_1: db 24,"*** Assertion failed in "
__assert_msg_2: db 7,", line "

__assertpassed: dw 0
__assertfailed: dw 0

;
; Signed 16 bits integer to string
;
; Entry:  HL (buffer), DE (value)
; Exit:   A (length)
; Uses:   *
;
__itoa:         ld      bc,0
                bit     7,d                
                ex      de,hl
                jr      z,__itoa_loop1
                ex      de,hl
                ld      (hl),'-'
                inc     hl
                inc     c
                push    hl
                ld      hl,0
                and     a
                sbc     hl,de
                pop     de
__itoa_loop1:   push    bc              ; mod 10 and push
                call    __div10
                pop     bc
                add     a,'0'
                push    af
                inc     b
                ld      a,h
                or      l
                jr      nz,__itoa_loop1
                ex      de,hl
__itoa_loop2:   pop     af              ; pop and store
                ld      (hl),a
                inc     hl
                inc     c
                djnz    __itoa_loop2
                ld      a,c
                ret

;
; String to signed 16 bits integer
;
; Entry:    HL (buffer), A (length)
; Exit:     DE (value)
; Uses:     *
;
; TODO Report errors via carry or a register? 
;
__atoi:         ld      de,0
                and     a
                ret     z
                ld      b,a
                ld      a,(hl)
                ld      c,a
                cp      '-'
                jr      z,__atoi_skip   ; Skip minus sign
                cp      '+'
                jr      z,__atoi_skip   ; Skip plus sign
__atoi_loop:    sub     '0'
                jr      c,__atoi_done   ; Not a digit
                cp      10
                jr      nc,__atoi_done  ; Not a digit
                push    hl
                call    __mul10
                ld      l,a
                ld      h,0
                add     hl,de
                ex      hl,de
                pop     hl
__atoi_skip:    inc     hl
                ld      a,(hl)
                djnz    __atoi_loop
__atoi_done:    ld      a,c             ; Fix sign, if necessary
                cp      '-'
                ret     nz
                and     a
                ld      hl,0
                sbc     hl,de
                ex      de,hl
                ret

#if defined(CPM)
__textfg:     ld a,l
              add a,'0'
              ld  (__textfg_str+3),a
              ld hl,__textfg_str
              call  __puts
              ret
__textfg_str: db 3,27,'T',32
#endif

#if defined(NXT)
__textfg:     ld a,l
              ld  (__textfg_str+2),a
              ld hl,__textfg_str
              call  __puts
              ret
__textfg_str: db 2,16,0 ; No good in LAYER 2,1 - needs mapping
#endif

#if defined(CPM)
__textbg:     ld a,l
              add a,'0'
              ld  (__textbg_str+3),a
              ld hl,__textbg_str
              call  __puts
              ret
__textbg_str: db 3,27,'S',32
#endif

#if defined(NXT)
__textbg:     ld a,l
              ld  (__textbg_str+2),a
              ld hl,__textbg_str
              call  __puts
              ret
__textbg_str: db 2,17,0 ; No good in LAYER 2,1 - needs mapping
#endif

#if defined(CPM)
__gotoxy:     ld a,l
              add a,31
              ld  (__gotoxy_str+4),a
              ld a,e
              add a,31
              ld  (__gotoxy_str+3),a
              ld hl,__gotoxy_str
              call  __puts
              ret
__gotoxy_str: db 4,27,'Y',32,32
#endif

#if defined(NXT)
__gotoxy:     ld a,l
              dec   a
              ld  (__gotoxy_str+3),a
              ld a,e
              dec   a
              ld  (__gotoxy_str+2),a
              ld hl,__gotoxy_str
              call  __puts
              ret
__gotoxy_str: db 3,22,0,0
#endif

#if defined(CPM)
__clrscr:     ld hl,__clrscr_str
              call  __puts
              ret
__clrscr_str: db 4,27,'H',27,'J'
#endif

#if defined(NXT)
__clrscr:     ld hl,__clrscr_str
              call  __puts
              ret
__clrscr_str: db 1,14
#endif

#if defined(CPM)
__cursor_on:  ld hl,__cur_on_str
              call  __puts
              ret
__cur_on_str: db 2,27,'e'
#endif

#if defined(NXT)
__cursor_on:  ret
#endif

#if defined(CPM)
__cursor_off: ld hl,__cur_off_str
              call  __puts
              ret
__cur_off_str: db 2,27,'f'
#endif

#if defined(NXT)
__cursor_off: ret
#endif

;
; Poke
;
; Entry:  HL (addr), E (value)
; Exit:   -
; Uses:   -
;
__poke:         ld      (hl),e
                ret


#if defined(LORES)
;
;
;
;
;
;
__pixel_addr:   sla     l
                rr      e
                rr      l
                ld      h,e
                ld      a,h
                cp      $18
                jr      c,__pixel_addr1
                ld      de,$6000
                jr      __pixel_addr2
__pixel_addr1:  ld      de,$4000
__pixel_addr2:  add     hl,de
                ret
;
; Set a pixel in low-res mode
;
; Entry:    HL  x       (0..128)
;           DE  y       (0..95)
;           BC  color   (0..255)
;
__set_pixel:    call    __pixel_addr
                ld      (hl),c
                ret

;
; Get a pixel in LAYER 2,1
;
; Entry:    HL  x       (0..255)
;           DE  y       (0..191)
;
__get_pixel:    call    __pixel_addr
                ld      l,(hl)
                ld      h,0
                ret


#endif

#if defined(HIRES)
__back_buffer:  db      18


__set_frontbuf: ld      a,l
                srl     a
                db      $ed,$92,$12
                ret

__set_backbuf:  ld      a,l
                ld      (__back_buffer),a
                srl     a
                db      $ed,$92,$13

                ret

__wait_vsync:   halt
                ret
;
; Set a pixel in LAYER 2,1
;
; Entry:    HL  x       (0..255)
;           DE  y       (0..191)
;           BC  color   (0..255)
;
__set_pixel:    di
                ld      d,e
                srl     d
                srl     d
                srl     d
                srl     d
                srl     d
                ld      a,(__back_buffer)
                add     a,d

                db      $ed,$92,$56

                ld      a,e
                and     31
                ld      h,a

                ld      de,$c000
                add     hl,de
                ld      (hl),c

                db      $ed,$91,$56,$00

                ei
                ret

;
; Get a pixel in LAYER 2,1
;
; Entry:    HL  x       (0..255)
;           DE  y       (0..191)
;
__get_pixel:    di
                ld      d,e
                srl     d
                srl     d
                srl     d
                srl     d
                srl     d
                ld      a,(__back_buffer)
                add     a,d

                db      $ed,$92,$56

                ld      a,e
                and     31
                ld      h,a

                ld      de,$c000
                add     hl,de
                ld      a,(hl)
                ld      h,0
                ld      l,a

                db      $ed,$91,$56,$00

                ei
                ret


#endif

;__peek:
;__poke:

;__border:
;__setpixel:
;__getpixel:

__heapptr:
        dw      0

; In: HL pointer address, DE size
; Out: -
__getmem:
        push    ix
        push    hl
        call    __malloc
        pop     hl
        ld      a,ixl
        ld      (hl),a
        inc     hl
        ld      a,ixh
        ld      (hl),a
        pop     ix
        ret

; In: DE size
; Out: IX new block
__malloc:
;        db      $dd,01,00,00
        ld      bc,__heapptr
        ld      ix,(__heapptr)
__malloc_loop:
; Null pointer means heap exhausted
        ld      a,ixh
        or      ixl
        jr      z,__malloc_out_of_memory
; Check size of free block
        ld      l,(ix+2)
        ld      h,(ix+3)
        and     a
        sbc     hl,de
        jr      c,__malloc_next
        jr      nz,__malloc_check_larger
; Case 1: Block of exact size found, just remove if from list
        ld      a,(ix+0)
        ld      (bc),a
        inc     bc
        ld      a,(ix+1)
        ld      (bc),a
        ret
; Larger blocks can be split, if at least 4 bytes remain 
__malloc_check_larger:
        ld      a,252
        and     l
        or      h
        jr      z,__malloc_next
; Case 2: Suitable larger block found, split it and adjust pointers
        exx
        ld      c,(ix+0)
        ld      b,(ix+1)
        exx

        push    ix
        add     ix,de
        exx
        ld      (ix+0),c
        ld      (ix+1),b
        exx
        ld      (ix+2),l
        ld      (ix+3),h

        ld      a,ixl
        ld      (bc),a
        inc     bc
        ld      a,ixh
        ld      (bc),a

        pop     ix

        ret
; Try next block
__malloc_next:
        ld      bc,ix
        exx
        ld      e,(ix+0)
        ld      d,(ix+1)
        ld      ix,de
        exx
        jp      __malloc_loop
; Display error message and freeze
__malloc_out_of_memory:
        ld      hl,__malloc_error_message
        call    __puts
__malloc_infinite_loop:
        jp      __malloc_infinite_loop
__malloc_error_message:
        db      13,'Out of memory'

; In: HL pointer, DE size
__freemem:
;        db      $dd,01,00,00
        ld      bc,(__heapptr)
        ld      (hl),c
        inc     hl
        ld      (hl),b
        inc     hl
        ld      (hl),e
        inc     hl
        ld      (hl),d
        dec     hl
        dec     hl
        dec     hl
        ld      (__heapptr),hl
        ret

__get_heap_start:
                ld      hl, eof
                ret

__get_heap_bytes:
                ld      hl, 57344
                ld      de, eof
                and     a
                sbc     hl,de
                ret

;
; Startup (with some help from Melissa O'Neill for NXT case)
;
; Entry: -
; Exit: -
; Uses: *
;
#if defined(CPM)
__init:         ret
#endif

#if defined(NXT)
__init:         ld      (__saved_iy),iy
                ld      de, $01d5
                ld      a,1
                exx
#if defined(LORES)
                ld      bc,$0100
#endif
#if defined(HIRES)
                ld      bc,$0201
#endif
                exx
                ld      c,7
                rst     $08
                db      $94
                exx
                ld   (__win_handle),hl
                exx
                ret
#endif

;
; Shutdown
;
; Entry: -
; Exit: -
; Uses: *
;
#if defined(CPM)
__done:         ret
#endif

#if defined(NXT)
__done:         ld      iy,(__saved_iy)
                ret
#endif
; 
                jp      main
; 
; [0] (* Built-ins that do not have to be defined in the compiler itself. *)
; [1] 
; [2] type
; [3]   PBlock = ^TBlock;
; [4]   TBlock = record
; [5]     Next: PBlock;
; [6]     Size: Integer;
; [7]   end;
; [8] 
; [9] var
; [10]   HeapPtr: PBlock absolute '__heapptr';
; [11] 
; [12]   AssertPassed: Integer absolute '__assertpassed';
; [13]   AssertFailed: Integer absolute '__assertfailed';
; [14] 
; [15] procedure FreeMem(P: Pointer; Size: Integer); register; external '__freemem';
; [16] (*var
; [17]   Q: PBlock;
; [18] begin
; [19]   Q := P;
; [20]   Q^.Size := Size;
; [21]   Q^.Next := HeapPtr;
; [22]   HeapPtr := Q;
; [23]   P := nil;
; [24] end;
; [25] *)
; [26] 
; [27] procedure GetMem(var P: Pointer; Size: Integer); register; external '__getmem';
; 
; [28] (*var
; [29]   Q, R: PBlock;
; [30] begin
; [31]   Q := nil;
; [32]   R := HeapPtr;
; [33]   while R <> nil do
; [34]   begin
; [35]     if R^.Size = Size then
; [36]     begin
; [37]       if Q = nil then
; [38]         HeapPtr := R^.Next
; [39]       else
; [40]         Q^.Next := R^.Next;
; [41] 
; [42]       P := R;
; [43] 
; [44]       Exit;
; [45]     end
; [46]     else if R^.Size >= Size + 4 then
; [47]     begin
; [48]       if Q = nil then
; [49]       begin
; [50]         HeapPtr := Ptr(Ord(R) + Size);
; [51]         HeapPtr^.Size := R^.Size - Size;
; [52]         HeapPtr^.Next := R^.Next;
; [53]       end
; [54]       else
; [55]       begin
; [56]         Q^.Next := Ptr(Ord(R) + Size);
; [57]         Q^.Next^.Size := R^.Size - Size;
; [58]         Q^.Next^.Next := R^.Next;
; [59]       end;
; [60] 
; [61]       P := R;
; [62] 
; [63]       Exit;
; [64]     end;
; [65] 
; [66]     Q := R;
; [67]     R := R^.Next;
; [68]   end;
; [69] 
; [70]   WriteLn('Out of memory error');
; [71]   while True do;
; [72] end;
; [73] *)
; [74] procedure InitHeap(Bytes: Integer);
; 
; [75] var
; [76]   P: Pointer;
; [77] begin
; var Bytes(+6), P(-2)
; 
proc2:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [78]   HeapPtr := nil;
                ld      hl,__heapptr    ; Get global HeapPtr
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [79]   P := Ptr(32768); (* GetHeapStart; *)
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,32768        ; Literal 32768
                pop     hl
                ld      (hl),de
; [80]   FreeMem(P, Bytes);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __freemem
; [81] end;
exit3:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [82] 
; [83] function MemAvail: Integer;
; 
; [84] var
; [85]   P: PBlock;
; [86]   I: Integer;
; [87] begin
; var MemAvail(+6), P(-2), I(-4)
; 
func4:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-4
                add     hl,sp
                ld      sp,hl
; [88]   P := HeapPtr;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,__heapptr    ; Get global HeapPtr
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [89]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [90]   while P <> nil do
while6:
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [91]   begin
                pop     af
                jp      nc,false7
; [92]     I := I + P^.Size;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [93]     P := P^.Next;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [94]   end;
                jp      while6
false7:
; [95] 
; [96]   MemAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [97] end;
exit5:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [98] 
; [99] function MaxAvail: Integer;
; 
; [100] var
; [101]   P: PBlock;
; [102]   I: Integer;
; [103] begin
; var MaxAvail(+6), P(-2), I(-4)
; 
func8:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-4
                add     hl,sp
                ld      sp,hl
; [104]   P := HeapPtr;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      hl,__heapptr    ; Get global HeapPtr
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [105]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [106]   while P <> nil do
while10:
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [107]   begin
                pop     af
                jp      nc,false11
; [108]     if P^.Size > I then I := P^.Size;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,false12
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
false12:
; [109]     P := P^.Next;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [110]   end;
                jp      while10
false11:
; [111] 
; [112]   MaxAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [113] end;
exit9:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [114] 
; [115] type
; 
; [116]   TString = String[255];
; [117] 
; [118] function Random(Range: Integer): Integer; register; external '__random';
; [119] 
; [120] function Length(S: TString): Integer; stdcall; external '__length';
; 
; [121] function Concat(S, T: TString): TString; stdcall; external '__concat';
; 
; [122] function Pos(S, T: TString): Integer; stdcall; external '__pos';
; 
; [123] function Copy(S: TString; Start: Integer; Count: Integer): TString; stdcall; external '__copy';
; 
; [124] procedure Insert(S: TString; var T: TString; Start: Integer); stdcall; external '__insert';
; 
; [125] procedure Delete(var S: TString; Start: Integer; Count: Integer); stdcall; external '__delete';
; 
; [126] 
; [127] {
; [128]   procedure Val(S: TString; var I, Code: Integer); stdcall; external '__val_int';
; [129] procedure Str(I: Integer; var S: TString); stdcall; external '__str_int';
; [130] }
; [131] 
; [132] procedure ClrScr; register; external '__clrscr';
; 
; [133] procedure GotoXY(X, Y: Integer); register; external '__gotoxy';
; 
; [134] procedure TextColor(I: Integer); register; external '__textfg';
; 
; [135] procedure TextBackground(I: Integer); register; external '__textbg';
; 
; [136] procedure CursorOn; register; external '__cursor_on';
; 
; [137] procedure CursorOff; register; external '__cursor_off';
; 
; [138] 
; [139] (* Arithmetic functions *)
; [140] 
; [141] (* function Abs(I: Integer): Integer  *) (* built-in *)
; [142] (* function Abs(R: Real): Real        *) (* built-in *)
; [143] function ArcTan(R: Real): Real; register; external 'ATN';
; 
; [144] function Cos(R: Real): Real; register; external 'COS';
; 
; [145] function Exp(R: Real): Real; register; external 'EXP';
; 
; [146] function Frac(R: Real): Real; register; external 'FRAC';
; 
; [147] function Int(R: Real): Real; register; external 'INT';
; 
; [148] function Ln(R: Real): Real; register; external 'LN';
; 
; [149] function Log(R: Real): Real; register; external 'LOG';
; 
; [150] function Pi: Real; register; external 'ACPI';
; 
; [151] function Sin(R: Real): Real; register; external 'SIN';
; 
; [152] function Sqr(R: Real): Real; register; external '__fltpwr2';
; 
; [153] function Sqrt(R: Real): Real; register; external 'SQR';
; 
; [154] function Tan(R: Real): Real; register; external 'TAN';
; 
; [155] 
; [156] (* Scalar functions *
; [157] 
; [158] (* Pred, Succ, Odd *)
; [159] 
; [160] (* Transfer functions *)
; [161] 
; [162] (* Chr, Ord, Round, Trunc *)
; [163] 
; [164] function Fix(R: Real): Integer; register; external 'FIX';
; 
; [165] 
; [166] (* Miscellaneous functions *)
; [167] 
; [168] (* 
; [169]   Hi ld l,h, ld h,0
; [170]   KeyPressed
; [171]   Lo ld h,0
; [172]   Random
; [173]   Random(I)
; [174]   ParamCount
; [175]   ParamStr
; [176]   SizeOf ok
; [177]   Swap ld a,h, ld h,l, ld l,a
; [178]   UpCase  -> lib z80
; [179] *)
; [0] program Monkey;
; 
; [1] 
; [2] {$i /Users/joerg/Projekte/pl0/lib/Files.pas}
; [0] type
; [1]   FileControlBlock = record
; [2]     DR: Byte;
; [3]     FN: array[0..7] of Char;
; [4]     TN: array[0..2] of Char;
; [5]     EX, S1, S2, RC: Byte;
; [6]     AL: array[0..15] of Byte;
; [7]     CR: Byte;
; [8]     RN: array[0..2] of Byte;
; [9]   end;
; [10] 
; [11]   Text = record
; [12]     Offset: Integer;
; [13]     Writing: Boolean;
; [14]     FCB: FileControlBlock;
; [15]     DMA: array[0..127] of Char;
; [16]   end;
; [17] 
; [18] procedure Assign(var T: Text; S: TString);
; [19] var
; [20]   I: Integer;
; [21] begin
; var T(+262), S(+6), I(-2)
; 
proc39:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [22]   T.FCB.DR := 0;
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [23] 
; [24]   for I := 1 to 8 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                ld      de,8            ; Literal 8
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak42
forloop41:
; [25]     T.FCB.FN[I - 1] := S[I];
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
fornext43:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak42
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop41
forbreak42:     pop     de              ; Cleanup limit
; [26] 
; [27]   for I := 10 to 12 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,10           ; Literal 10
                pop     hl
                ld      (hl),de
                ld      de,12           ; Literal 12
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak45
forloop44:
; [28]     T.FCB.TN[I - 10] := S[I];
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,9            ; Literal 9
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,10           ; Literal 10
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
fornext46:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak45
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop44
forbreak45:     pop     de              ; Cleanup limit
; [29] end;
exit40:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [30] 
; [31] procedure Reset(var T: Text);
; 
; [32] var
; [33]   A: Integer;
; [34] begin
; var T(+6), A(-2)
; 
proc47:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [35]   T.FCB.EX := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,12           ; Literal 12
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [36]   T.FCB.S1 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,13           ; Literal 13
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [37]   T.FCB.S2 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,14           ; Literal 14
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [38]   T.FCB.RC := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,15           ; Literal 15
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [39]   T.FCB.CR := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,32           ; Literal 32
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [40] 
; [41]   T.Writing := False;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [42] 
; [43]   A := Bdos(15, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,15           ; Literal 15
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [44] 
; [45]   T.Offset := 128;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,128          ; Literal 128
                pop     hl
                ld      (hl),de
; [46] end;
exit48:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [47] 
; [48] procedure Rewrite(var T: Text);
; 
; [49] var
; [50]   A: Integer;
; [51] begin
; var T(+6), A(-2)
; 
proc49:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [52]   T.FCB.EX := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,12           ; Literal 12
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [53]   T.FCB.S1 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,13           ; Literal 13
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [54]   T.FCB.S2 := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,14           ; Literal 14
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [55]   T.FCB.RC := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,15           ; Literal 15
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [56]   T.FCB.CR := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                push    hl
                ld      de,32           ; Literal 32
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [57] 
; [58]   T.Writing := True;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),e
; [59] 
; [60]   A := Bdos(19, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [61]   A := Bdos(22, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,22           ; Literal 22
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [62] 
; [63]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [64] end;
exit50:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [65] 
; [66] procedure ReadRec(var T: Text);
; 
; [67] var
; [68]   A: Integer;
; [69] begin
; var T(+6), A(-2)
; 
proc51:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [70]   A := Bdos(26, Addr(T.DMA));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [71]   A := Bdos(20, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,20           ; Literal 20
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [72]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [73] end;
exit52:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [74] 
; [75] function ReadChar(var T: Text): Char;
; 
; [76] var
; [77]   C: Char;
; [78] begin
; var ReadChar(+8), T(+6), C(-2)
; 
func53:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [79]   if T.Offset > 127 then ReadRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,127          ; Literal 127
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,false55
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc51
; Cleanup 2 bytes
                pop     hl
false55:
; [80]   C := T.DMA[T.Offset];
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [81]   if C <> #26 then T.Offset := T.Offset + 1;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,26           ; Literal 26
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,false56
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
false56:
; [82]   ReadChar := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [83] end;
exit54:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [84] 
; [85] procedure ReadLine(var T: Text; var S: TString);
; 
; [86] var
; [87]   C: Char;
; [88] begin
; var T(+8), S(+6), C(-2)
; 
proc57:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [89]   S := '';
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,string59
                pop     de
                ld      a,255
                call    __movestr
; [90] 
; [91]   while Length(S) < 255 do
while60:
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [92]   begin
                pop     af
                jp      nc,false61
; [93]     C := ReadChar(T);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    func53
; Cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),e
; [94] 
; [95]     if C = #10 then Break;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,10           ; Literal 10
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,false62
                jp      false61         ; Break
false62:
; [96]     if C = #26 then Break;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,26           ; Literal 26
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,false63
                jp      false61         ; Break
false63:
; [97] 
; [98]     if C >= ' ' then S := S + C;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,32           ; Literal 32
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,false64
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      d,e
                ld      e,1
                push    de
                call    __stradd
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
false64:
; [99]   end;
                jp      while60
false61:
; [100] end;
exit58:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [101] 
; [102] procedure WriteRec(var T: Text);
; 
; [103] var
; [104]   A: Integer;
; [105] begin
; var T(+6), A(-2)
; 
proc65:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [106]   A := Bdos(26, Addr(T.DMA));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [107]   A := Bdos(21, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,21           ; Literal 21
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [108]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [109] end;
exit66:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [110] 
; [111] 
; [112] procedure WriteChar(var T: Text; C: Char);
; 
; [113] begin
; var T(+8), C(+6)
; 
proc67:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,0
                add     hl,sp
                ld      sp,hl
; [114]   if T.Offset > 127 then WriteRec(T);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,127          ; Literal 127
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,false69
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc65
; Cleanup 2 bytes
                pop     hl
false69:
; [115]   T.DMA[T.Offset] := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [116]   T.Offset := T.Offset + 1;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [117] end;
exit68:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [118] 
; [119] procedure WriteLine(var T: Text; S: TString);
; 
; [120] var
; [121]   I: Integer;
; [122] begin
; var T(+262), S(+6), I(-2)
; 
proc70:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [123]   for I := 1 to Length(S) do WriteChar(T, S[I]);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak73
forloop72:
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                call    proc67
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
fornext74:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak73
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop72
forbreak73:     pop     de              ; Cleanup limit
; [124] 
; [125]   WriteChar(T, #13);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,13           ; Literal 13
                push    de
                call    proc67
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [126]   WriteChar(T, #10);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,10           ; Literal 10
                push    de
                call    proc67
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [127] end;
exit71:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [128] 
; [129] function IsEof(var T: Text): Boolean;
; 
; [130] begin
; var IsEof(+8), T(+6)
; 
func75:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,0
                add     hl,sp
                ld      sp,hl
; [131]   if T.Offset > 127 then ReadRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,127          ; Literal 127
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,false77
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc51
; Cleanup 2 bytes
                pop     hl
false77:
; [132]   IsEof := T.DMA[T.Offset] = #26;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,39           ; Literal 39
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,26           ; Literal 26
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ld      de,hl
                pop     hl
                ld      (hl),e
; [133] end;        
exit76:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [134] 
; [135] procedure Close(var T: Text);
; 
; [136] var
; [137]   A: Integer;
; [138] begin
; var T(+6), A(-2)
; 
proc78:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [139]   if T.Writing then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
; [140]   begin
                pop     af
                jp      nc,false80
; [141]     WriteChar(T, #26);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,26           ; Literal 26
                push    de
                call    proc67
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [142]     WriteRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc65
; Cleanup 2 bytes
                pop     hl
; [143]   end;
false80:
; [144] 
; [145]   A := Bdos(16, Addr(T.FCB));
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,16           ; Literal 16
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ld      de,hl
                pop     hl
                ld      (hl),de
; [146] end;
exit79:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [3] {$i bigint.pas}
; [0] {$L bigint.asm}
                include "bigint.asm"
;
; Unsigned big integer math routines adapted from:
;
; Leventhal / Saville: Z80 Assembly Language Subroutines
;

;
; BigAdd: HL^ := HL^+ DE^
;
bigadd:
#local
        ld      b,8
        and     a
        ex      af,af'
bigadd1:
        ex      af,af'
        ld      a,(de)
        adc     (hl)
        ld      (hl),a
        ex      af,af'
        inc     hl
        inc     de
        djnz    bigadd1
        ret
#endlocal

;
; BigSub: HL^ := HL^ - DE^
;
bigsub:
#local
        ex      de,hl
        ld      b,8
        and     a
        ex      af,af'
bigsub1:
        ex      af,af'
        ld      a,(de)
        sbc     (hl)
        ld      (de),a
        ex      af,af'
        inc     hl
        inc     de
        djnz    bigsub1
        ret
#endlocal

;
; BigMul: HL^ := HL^ * DE^
;
bigmul:
#local
        ld      c,8
        ld      b,0
        add     hl,bc
        ex      de,hl
        ld      (mlier),hl
        ld      hl,hiprod
        add     hl,bc
        ld      (endhp),hl

        ld      l,c
        ld      h,b
        add     hl,hl
        add     hl,hl
        add     hl,hl
        inc     hl
        ld      (count),hl
zeropd:
        ld      b,c
        ld      hl,hiprod
zerolp:
        ld      (hl),0
        inc     hl
        djnz    zerolp

        and     a
loop:
        ld      b,c
        ld      hl,(endhp)
srplp:
        dec     hl
        rr      (hl)
        djnz    srplp

        ld      l,e
        ld      h,d
        ld      b,c
srailp:
        dec     hl
        rr      (hl)
        djnz    srailp

        jp      nc,deccnt

        push    de
        ld      de,(mlier)
        ld      hl,hiprod
        ld      b,c
        and     a
addlp:
        ld      a,(de)
        adc     a,(hl)
        ld      (hl),a
        inc     de
        inc     hl
        djnz    addlp
        pop     de

deccnt:
        ld      a,(count)
        dec     a
        ld      (count),a
        jp      nz,loop
        push    af
        ld      a,(count+1)
        and     a
        jp      z,exit
        dec     a
        ld      (count+1),a
        pop     af
        jp      loop
exit:
        pop     af
        ret

count:  ds      2
endhp:  ds      2
mlier:  ds      2
hiprod: ds      8
#endlocal

;
; BigDiv: HL^ := HL^ / DE^ and DE^ := HL^ % DE^
;
bigdiv:
#local
        ld      (dvend),hl
        ld      (dvsor),de
        push    bc
        ld      c,8

        ld      l,c
        ld      h,0
        add     hl,hl
        add     hl,hl
        add     hl,hl
        inc     hl
        ld      (count),hl

        ld      hl,hide1
        ld      de,hide2
        ld      b,c
        sub     a
zerolp:
        ld      (hl),a
        ld      (de),a
        inc     hl
        inc     de
        djnz    zerolp

        ld      hl,hide1
        ld      (hdeptr),hl

        ld      hl,hide2
        ld      (odeptr),hl

        ld      hl,(dvsor)
        ld      b,c
        sub     a
chkolp:
        or      (hl)
        inc     hl
        djnz    chkolp
        or      a
        jr      z,erexit

        or      a

loop:
        ld      b,c
        ld      hl,(dvend)
sllp1:
        rl      (hl)
        inc     hl
        djnz    sllp1

deccnt:
        ld      a,(count)
        dec     a
        ld      (count),a
        jr      nz,cont
        ld      a,(count+1)
        dec     a
        ld      (count+1),a
        jp      m,okexit

cont:
        ld      hl,(hdeptr)
        ld      b,c
sllp2:
        rl      (hl)
        inc     hl
        djnz    sllp2

        push    bc
        ld      a,c
        ld      (subcnt),a
        ld      bc,(odeptr)
        ld      de,(hdeptr)
        ld      hl,(dvsor)
        or      a
sublp:
        ld      a,(de)
        sbc     a,(hl)
        ld      (bc),a
        inc     hl
        inc     de
        inc     bc
        ld      a,(subcnt)
        dec     a
        ld      (subcnt),a
        jr      nz,sublp
        pop     bc

        ccf
        jr      nc,loop
        ld      hl,(hdeptr)
        ld      de,(odeptr)
        ld      (odeptr),hl
        ld      (hdeptr),de

        jp      loop

erexit:
        scf
        jp      exit

okexit:
        or      a

exit:
        ld      hl,(hdeptr)
        pop     de
        ld      bc,8
        ldir

        ret

dvend:  ds      2
dvsor:  ds      2
hdeptr: ds      2
odeptr: ds      2
count:  ds      2
subcnt: ds      1
hide1:  ds      8
hide2:  ds      8
#endlocal
; [1] 
; [2] type
; 
; [3]   BigInt = array[0..7] of Byte;
; [4] 
; [5] const
; [6]   BigMin: BigInt = (0, 0, 0, 0, 0, 0, 0, 0);
const81:
                db      0,0,0,0,0,0,0,0
; [7]   BigMax: BigInt = (255, 255, 255, 255, 255, 255, 255, 127);
const82:
                db      255,255,255,255,255,255,255,127
; [8]   BigOne: BigInt = (1, 0, 0, 0, 0, 0, 0, 0);
const83:
                db      1,0,0,0,0,0,0,0
; [9]   BigTen: BigInt = (10, 0, 0, 0, 0, 0, 0, 0);
const84:
                db      10,0,0,0,0,0,0,0
; [10] 
; [11] procedure BigAdd(var X, Y: BigInt); register; external 'bigadd';
; [12] procedure BigSub(var X, Y: BigInt); register; external 'bigsub';
; 
; [13] procedure BigMul(var X, Y: BigInt); register; external 'bigmul';
; 
; [14] procedure BigDiv(var X, Y, Z: BigInt); register; external 'bigdiv';
; 
; [15] 
; [16] function BigCmp(var X, Y: BigInt): Integer;
; 
; [17] var
; [18]   I: Integer;
; [19]   B: Byte;
; [20] begin
; var BigCmp(+10), X(+8), Y(+6), I(-2), B(-4)
; 
func89:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-4
                add     hl,sp
                ld      sp,hl
; [21]   for B := 7 downto 0 do
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,7            ; Literal 7
                pop     hl
                ld      (hl),e
                ld      de,0            ; Literal 0
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,de
                pop     de
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak92
forloop91:
; [22]   begin
; [23]     I := X[B] - Y[B];
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [24]     if I <> 0 then
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [25]     begin 
                pop     af
                jp      nc,false94
; [26]       BigCmp := I; 
                ld      de,ix
                ld      hl,10
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [27]       Exit;
                jp      exit90          ; Exit
; [28]     end;
false94:
; [29]   end;
fornext93:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak92
                ld      de,ix
                ld      hl,-4
                add     hl,de
                dec     (hl)
                jp      forloop91
forbreak92:     pop     de              ; Cleanup limit
; [30] 
; [31]   BigCmp := 0;
                ld      de,ix
                ld      hl,10
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [32] end;
exit90:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [33] 
; [34] procedure BigVal(S: TString; var X: BigInt);
; 
; [35] var
; [36]   B: Byte;
; [37]   Y: BigInt;
; [38]   I, J: Integer;
; [39] begin
; var S(+8), X(+6), B(-2), Y(-10), I(-12), J(-14)
; 
proc95:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-14
                add     hl,sp
                ld      sp,hl
; [40]   X := BigMin;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,const81      ; Get global BigMin
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [41] 
; [42]   if Length(S) < 3 then
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      de,3            ; Literal 3
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [43]   begin
                pop     af
                jp      nc,false97
; [44]     Val(S, I, J);
                ld      de,ix
                ld      hl,8
                add     hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,-12
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-14
                add     hl,de
                push    hl
                call    __val_int
; [45]     X[0] := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-12
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),e
; [46]     Exit;
                jp      exit96          ; Exit
; [47]   end;
false97:
; [48] 
; [49]   Y := BigMin;
                ld      de,ix
                ld      hl,-10
                add     hl,de
                push    hl
                ld      hl,const81      ; Get global BigMin
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [50] 
; [51]   for B := 1 to Length(S) do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),e
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak99
forloop98:
; [52]   begin
; [53]     BigMul(X, BigTen);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,const84      ; Get global BigTen
                ld      de,hl
                pop     hl
                call    bigmul
; [54]     Y[0] := Ord(S[B]) - 48;
                ld      de,ix
                ld      hl,-10
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,48           ; Literal 48
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                ld      (hl),e
; [55]     BigAdd(X, Y); 
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      de,hl
                pop     hl
                call    bigadd
; [56]   end;
fornext100:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak99
                ld      de,ix
                ld      hl,-2
                add     hl,de
                inc     (hl)
                jp      forloop98
forbreak99:     pop     de              ; Cleanup limit
; [57] end;
exit96:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [58] 
; [59] procedure BigStr(X: BigInt; var S: TString);
; 
; [60] var
; [61]   Y: BigInt;
; [62] begin
; var X(+8), S(+6), Y(-8)
; 
proc101:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
; [63]   S := '';
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,string59
                pop     de
                ld      a,255
                call    __movestr
; [64] 
; [65]   repeat
repeat103:
; [66]     BigDiv(X, BigTen, Y);
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,const84      ; Get global BigTen
                push    hl
                ld      de,ix
                ld      hl,-8
                add     hl,de
                push    hl
                pop     bc
                pop     de
                pop     hl
                call    bigdiv
; [67]     S := '' + Char(48 + Y[0]) + S;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,string59
                call    __loadstr
                ld      de,48           ; Literal 48
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      de,hl
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      d,e
                ld      e,1
                push    de
                call    __stradd
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                call    __loadstr
                call    __stradd
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
; [68]   until BigCmp(X, BigMin) = 0;
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,const81      ; Get global BigMin
                push    hl
                call    func89
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,repeat103
break104:
; [69] end;
exit102:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [4] 
; [5] type
; 
; [6]   NameStr = String[4];
; [7] 
; [8]   NodePtr = ^NodeRec;
; [9]   NodeRec = record
; [10]     Name: NameStr;
; [11] 
; [12]     case Leaf: Boolean of
; [13]       False: (Operator: Char; Left, Right: NodePtr;);
; [14]       True:  (Value: BigInt;);
; [15]   end;
; [16] 
; [17] var
; [18]   HashMap: array[0..7000] of NodePtr;
global105:      ds      14002           ; Global HashMap
; [19] 
; [20] procedure Init;
; [21] var
; [22]   I: Integer;
; [23] begin
; var I(-2)
; 
proc106:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [24]   for I := 0 to 7000 do
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
                ld      de,7000         ; Literal 7000
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak109
forloop108:
; [25]     HashMap[I] := nil;
                ld      hl,global105    ; Get global HashMap
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                add     hl,hl
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
fornext110:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                pop     af
                jp      nc,forbreak109
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                inc     de
                ld      (hl),de
                jp      forloop108
forbreak109:    pop     de              ; Cleanup limit
; [26] end;
exit107:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [27] 
; [28] function HashKey(Name: TString): Integer;
; 
; [29] var
; [30]   I: Integer;
; [31] begin
; var HashKey(+262), Name(+6), I(-2)
; 
func111:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-2
                add     hl,sp
                ld      sp,hl
; [32]   I := ((Ord(Name[1]) - 97) * 1000 + (Ord(Name[2]) - 97) * 100 + (Ord(Name[3]) - 97) * 10 + (Ord(Name[4]) - 97)) mod 7001;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,97           ; Literal 97
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                ld      de,1000         ; Literal 1000
                pop     hl
                call    __mul16         ; Mul
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,2            ; Literal 2
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,97           ; Literal 97
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                ld      de,100          ; Literal 100
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,3            ; Literal 3
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,97           ; Literal 97
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                ld      de,10           ; Literal 10
                pop     hl
                call    __mul16         ; Mul
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,97           ; Literal 97
                pop     hl
                xor     a
                sbc     hl,de
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,7001         ; Literal 7001
                pop     hl
                call    __sdiv16        ; Mod
                ex      hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [33]   HashKey := I;
                ld      de,ix
                ld      hl,262
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [34] end;
exit112:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [35] 
; [36] procedure Define(Node: NodePtr);
; 
; [37] var
; [38]   I: Integer;
; [39]   S: NameStr;
; [40] begin
; var Node(+6), I(-2), S(-7)
; 
proc113:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-7
                add     hl,sp
                ld      sp,hl
; [41]   S := Node^.Name;
                ld      de,ix
                ld      hl,-7
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                pop     de
                ld      a,4
                call    __movestr
; [42]   I := HashKey(S);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,-7
                add     hl,de
                call    __loadstr
                call    func111
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [43]   while HashMap[I] <> nil do
while115:
                ld      hl,global105    ; Get global HashMap
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                add     hl,hl
                ld      de,hl
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [44]   begin
                pop     af
                jp      nc,false116
; [45]     I := (I + Ord(Node^.Name[4])) mod 7001;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,7001         ; Literal 7001
                pop     hl
                call    __sdiv16        ; Mod
                ex      hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [46]   end;
                jp      while115
false116:
; [47] 
; [48]   HashMap[I] := Node;
                ld      hl,global105    ; Get global HashMap
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                add     hl,hl
                ld      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [49] end;
exit114:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [50] 
; [51] function Lookup(Name: TString): NodePtr;
; 
; [52] var
; [53]   I: Integer;
; [54]   P: NodePtr;
; [55] begin
; var Lookup(+262), Name(+6), I(-2), P(-4)
; 
func117:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-4
                add     hl,sp
                ld      sp,hl
; [56]   I := HashKey(Name);
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    func111
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [57]   P := HashMap[I];
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      hl,global105    ; Get global HashMap
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                add     hl,hl
                ld      de,hl
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [58]   while P <> nil do
while119:
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [59]   begin
                pop     af
                jp      nc,false120
; [60]     if P^.Name = Name then
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                call    __loadstr
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __streq
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                push    de
; [61]     begin
                pop     af
                jp      nc,false121
; [62]       Lookup := P;
                ld      de,ix
                ld      hl,262
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [63]       Exit;
                jp      exit118         ; Exit
; [64]     end;
false121:
; [65]     I := (I + Ord(Name[4])) mod 7001;
                ld      de,ix
                ld      hl,-2
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,4            ; Literal 4
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,7001         ; Literal 7001
                pop     hl
                call    __sdiv16        ; Mod
                ex      hl,de
                ld      de,hl
                pop     hl
                ld      (hl),de
; [66]     P := HashMap[I];
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      hl,global105    ; Get global HashMap
                push    hl
                ld      de,ix
                ld      hl,-2
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                add     hl,hl
                ld      de,hl
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [67]   end;
                jp      while119
false120:
; [68] 
; [69]   WriteLn('Error: ', Name, ' not found.');
                ld      hl,string122
                call    __puts
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __puts
                ld      hl,string123
                call    __puts
                call    __newline
; [70]   Lookup := nil;
                ld      de,ix
                ld      hl,262
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),de
; [71] end;
exit118:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [72] 
; [73] procedure Load;
; 
; [74] var
; [75]   T: Text;
; [76]   S, U: TString;
; [77]   N: NodePtr;
; [78]   I: Integer;
; [79] begin
; var T(-167), S(-423), U(-679), N(-681), I(-683)
; 
proc124:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-683
                add     hl,sp
                ld      sp,hl
; [80]   Assign(T, 'INPUT   .TXT');
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      hl,string126
                call    __loadstr
                call    proc39
; Cleanup 2 bytes
                pop     hl
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; [81] 
; [82]   WriteLn('Loading...');
                ld      hl,string127
                call    __puts
                call    __newline
; [83] 
; [84]   Reset(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc47
; Cleanup 2 bytes
                pop     hl
; [85]   while not IsEof(T) do
while128:
                push    hl
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    func75
; Cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
                push    hl
; [86]   begin
                pop     af
                jp      nc,false129
; [87]     ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc57
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [88]     if S = '' then Continue;
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      hl,string59
                call    __loadstr
                call    __streq
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                push    de
                pop     af
                jp      nc,false130
                jp      while128        ; Continue
false130:
; [89]     New(N);
                ld      de,ix
                ld      hl,-681
                add     hl,de
                push    hl
                ld      de,14           ; Literal 14
                pop     hl
                call    __getmem
; [90]     U := Copy(S, 1, 4);
                ld      de,ix
                ld      hl,-679
                add     hl,de
                push    hl
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      de,1            ; Literal 1
                push    de
                ld      de,4            ; Literal 4
                push    de
                call    __copy
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                ld      a,255
                call    __storestr
; [91]     N^.Name := U;           (* Bug: Should be N^.Name := Copy(...) *)
                ld      de,ix
                ld      hl,-681
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-679
                add     hl,de
                pop     de
                ld      a,4
                call    __movestr
; [92]     Define(N);              (* Bug: Crashes in Define              *)
                ld      de,ix
                ld      hl,-681
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc113
; Cleanup 2 bytes
                pop     hl
; [93]   end;
                jp      while128
false129:
; [94] 
; [95]   Close(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc78
; Cleanup 2 bytes
                pop     hl
; [96] 
; [97]   WriteLn('Resolving...');
                ld      hl,string131
                call    __puts
                call    __newline
; [98] 
; [99]   Reset(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc47
; Cleanup 2 bytes
                pop     hl
; [100]   while not IsEof(T) do
while132:
                push    hl
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    func75
; Cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
                push    hl
; [101]   begin
                pop     af
                jp      nc,false133
; [102]     ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc57
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [103]     if S = '' then Continue;
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      hl,string59
                call    __loadstr
                call    __streq
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                push    de
                pop     af
                jp      nc,false134
                jp      while132        ; Continue
false134:
; [104]     N := Lookup(Copy(S, 1, 4));
                ld      de,ix
                ld      hl,-681
                add     hl,de
                push    hl
                push    hl
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      de,1            ; Literal 1
                push    de
                ld      de,4            ; Literal 4
                push    de
                call    __copy
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                call    func117
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [105] 
; [106]     with N^ do
                ld      de,ix
                ld      hl,-681
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
; [107]     if Length(S) > 10 then
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                call    __length
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      de,10           ; Literal 10
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [108]     begin
                pop     af
                jp      nc,false135
; [109]       (* cqrh: bnph * jzrj *)
; [110] 
; [111]       Leaf := False;
                ld      de,ix
                ld      hl,-685
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                ld      de,5
                add     hl,de
                push    hl
                ld      de,0            ; Literal 0
                pop     hl
                ld      (hl),e
; [112] 
; [113]       Operator := S[12];
                ld      de,ix
                ld      hl,-685
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                ld      de,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                ld      de,12           ; Literal 12
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [114]       Left := Lookup(Copy(S, 7, 4));
                ld      de,ix
                ld      hl,-685
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                ld      de,7
                add     hl,de
                push    hl
                push    hl
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      de,7            ; Literal 7
                push    de
                ld      de,4            ; Literal 4
                push    de
                call    __copy
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                call    func117
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [115]       Right := Lookup(Copy(S, 14, 4));
                ld      de,ix
                ld      hl,-685
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                ld      de,9
                add     hl,de
                push    hl
                push    hl
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      de,14           ; Literal 14
                push    de
                ld      de,4            ; Literal 4
                push    de
                call    __copy
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                call    func117
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [116]     end
; [117]     else
                jp      endif136
false135:
; [118]     begin
; [119]       (* mbjq: 5 *)
; [120] 
; [121]       Leaf := True;
                ld      de,ix
                ld      hl,-685
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                ld      de,5
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),e
; [122] 
; [123]       BigVal(Copy(S, 7, 255), Value);
                ld      hl,-256         ; Space
                add     hl,sp
                ld      sp,hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      de,7            ; Literal 7
                push    de
                ld      de,255          ; Literal 255
                push    de
                call    __copy
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                ld      de,ix
                ld      hl,-685
                add     hl,de
                ld      de,(hl)
                ld      hl,de
                ld      de,6
                add     hl,de
                push    hl
                call    proc95
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; [124]     end;
endif136:
                pop     bc
; [125]   end;
                jp      while132
false133:
; [126] 
; [127]   Close(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc78
; Cleanup 2 bytes
                pop     hl
; [128] end;
exit125:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [129] 
; [130] procedure Eval(Part: Integer; Node: NodePtr; var Big: BigInt);
; 
; [131] const
; [132]   S: String = '';
const138:
                db      0
                ds      255
; [133] var
; [134]   Tmp, Tmp2: BigInt;
; [135] begin
; var Part(+10), Node(+8), Big(+6), S(0), Tmp(-8), Tmp2(-16)
; 
proc137:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-16
                add     hl,sp
                ld      sp,hl
; [136]   if Node^.Leaf then
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,5            ; Literal 5
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
; [137]     Big := Node^.Value
                pop     af
                jp      nc,false140
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,6            ; Literal 6
                pop     hl
                add     hl,de
                push    hl
; [138]   else
                pop     de              ; Load
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
                jp      endif141
false140:
; [139]   begin
; [140]     Eval(Part, Node^.Left, Big);
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,7            ; Literal 7
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    proc137
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [141]     Eval(Part, Node^.Right, Tmp);
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,9            ; Literal 9
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                push    hl
                call    proc137
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [142] 
; [143]     if Part = 1 then
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                push    hl
; [144]     begin
                pop     af
                jp      nc,false142
; [145]       GotoXY(1, 10);
                ld      de,1            ; Literal 1
                push    de
                ld      de,10           ; Literal 10
                pop     hl
                call    __gotoxy
; [146]       Write(#27'L');
                ld      hl,string143
                call    __puts
; [147]       BigStr(Big, S);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      hl,const138     ; Get global S
                push    hl
                call    proc101
; Cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [148]       Write(S:20);
                ld      hl,const138     ; Get global S
                call    __loadstr
                ld      de,20           ; Literal 20
                ld      bc,de
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                ld      hl,256
                add     hl,sp
                ld      sp,hl
; [149]       Write(' ', Node^.Operator, ' ');
                ld      de,32           ; Literal 32
                ld      hl,de
                ld      a,l
                call    __putc
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,6            ; Literal 6
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,de
                ld      a,l
                call    __putc
                ld      de,32           ; Literal 32
                ld      hl,de
                ld      a,l
                call    __putc
; [150]       BigStr(Tmp, S);
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      hl,const138     ; Get global S
                push    hl
                call    proc101
; Cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [151]       Write(S:20);
                ld      hl,const138     ; Get global S
                call    __loadstr
                ld      de,20           ; Literal 20
                ld      bc,de
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                ld      hl,256
                add     hl,sp
                ld      sp,hl
; [152]       Write(' = ');
                ld      hl,string144
                call    __puts
; [153]     end;
false142:
; [154] 
; [155]     case Node^.Operator of
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,6            ; Literal 6
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
; [156]       '+': BigAdd(Big, Tmp);
                ld      hl,43
                call    __int16_eq
                and     a
                jp      nz,case146
                jp      test147
case146:
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,hl
                pop     hl
                call    bigadd
; [157]       '-': BigSub(Big, Tmp);
                jp      end145
test147:
                ld      hl,45
                call    __int16_eq
                and     a
                jp      nz,case148
                jp      test149
case148:
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,hl
                pop     hl
                call    bigsub
; [158]       '*': BigMul(Big, Tmp);
                jp      end145
test149:
                ld      hl,42
                call    __int16_eq
                and     a
                jp      nz,case150
                jp      test151
case150:
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,hl
                pop     hl
                call    bigmul
; [159]       '/': BigDiv(Big, Tmp, Tmp2);
                jp      end145
test151:
                ld      hl,47
                call    __int16_eq
                and     a
                jp      nz,case152
                jp      test153
case152:
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-16
                add     hl,de
                push    hl
                pop     bc
                pop     de
                pop     hl
                call    bigdiv
; [160]     else
                jp      end145
test153:
; [161]       WriteLn('Oops: ', Node^.Operator);
                ld      hl,string154
                call    __puts
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,6            ; Literal 6
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,de
                ld      a,l
                call    __putc
                call    __newline
; [162]     end;
end145:
; [163] 
; [164]     if Part = 1 then
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                push    hl
; [165]     begin
                pop     af
                jp      nc,false155
; [166]       BigStr(Big, S);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      hl,const138     ; Get global S
                push    hl
                call    proc101
; Cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [167]       Write(S:20);
                ld      hl,const138     ; Get global S
                call    __loadstr
                ld      de,20           ; Literal 20
                ld      bc,de
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                ld      hl,256
                add     hl,sp
                ld      sp,hl
; [168]     end;
false155:
; [169] 
; [170]     if Node^.Left^.Leaf and (Node^.Left^.Name <> 'humn') then
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,7            ; Literal 7
                pop     hl
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,5            ; Literal 5
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,7            ; Literal 7
                pop     hl
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                call    __loadstr
                ld      hl,string156
                call    __loadstr
                call    __streq
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      hl,de
                ld      a,1
                xor     l
                ld      l,a
                ld      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                push    hl
; [171]       if Node^.Right^.Leaf and (Node^.Right^.Name <> 'humn') then
                pop     af
                jp      nc,false157
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,9            ; Literal 9
                pop     hl
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,5            ; Literal 5
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,9            ; Literal 9
                pop     hl
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                add     hl,de
                call    __loadstr
                ld      hl,string156
                call    __loadstr
                call    __streq
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      hl,de
                ld      a,1
                xor     l
                ld      l,a
                ld      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                push    hl
; [172]       begin
                pop     af
                jp      nc,false158
; [173]         Node^.Value := Big;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,6            ; Literal 6
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      de,(hl)
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [174]         Node^.Leaf := True;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,5            ; Literal 5
                pop     hl
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                pop     hl
                ld      (hl),e
; [175]       end;
false158:
false157:
; [176]   end;
endif141:
; [177] end;
exit139:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [178] 
; [179] var
; 
; [180]   Root, Humn: NodePtr;
global159:      ds      2               ; Global Root
global160:      ds      2               ; Global Humn
; [181]   I, J, L, H, T, R, Left, Right: BigInt;
global161:      ds      8               ; Global I
global162:      ds      8               ; Global J
global163:      ds      8               ; Global L
global164:      ds      8               ; Global H
global165:      ds      8               ; Global T
global166:      ds      8               ; Global R
global167:      ds      8               ; Global Left
global168:      ds      8               ; Global Right
; [182]   S: TString;
global169:      ds      256             ; Global S
; [183]   C: Integer;
global170:      ds      2               ; Global C
; [184] 
; [185] begin
; var Mem(0), HeapPtr(0), AssertPassed(0), AssertFailed(0), BigMin(0), BigMax(0), BigOne(0), BigTen(0), HashMap(0), Root(0), Humn(0), I(0), J(0), L(0), H(0), T(0), R(0), Left(0), Right(0), S(0), C(0)
; 
main:           call    __init
                ld      ix,0
                add     ix,sp
; [186]   InitHeap(24576);
                ld      de,24576        ; Literal 24576
                push    de
                call    proc2
; Cleanup 2 bytes
                pop     hl
; [187] 
; [188]   Write(#27'f');
                ld      hl,string172
                call    __puts
; [189] 
; [190]   ClrScr;
                call    __clrscr
; [191] 
; [192]   WriteLn('*** AoC 2022.21 Monkey Math ***');
                ld      hl,string173
                call    __puts
                call    __newline
; [193]   WriteLn;
                call    __newline
; [194] 
; [195]   Init;
                call    proc106
; [196]   Load;
                call    proc124
; [197] 
; [198]   Root := Lookup('root');
                ld      hl,global159    ; Get global Root
                push    hl
                push    hl
                ld      hl,string174
                call    __loadstr
                call    func117
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [199]   Humn := Lookup('humn');
                ld      hl,global160    ; Get global Humn
                push    hl
                push    hl
                ld      hl,string156
                call    __loadstr
                call    func117
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [200]   
; [201] 
; [202]   Eval(1, Lookup('root'), I);
                ld      de,1            ; Literal 1
                push    de
                push    hl
                ld      hl,string174
                call    __loadstr
                call    func117
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      hl,global161    ; Get global I
                push    hl
                call    proc137
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [203]   BigStr(I, S);
                ld      hl,global161    ; Get global I
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      hl,global169    ; Get global S
                push    hl
                call    proc101
; Cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [204] 
; [205]   GotoXY(1, 6);
                ld      de,1            ; Literal 1
                push    de
                ld      de,6            ; Literal 6
                pop     hl
                call    __gotoxy
; [206]   WriteLn('Part 1: ', S);
                ld      hl,string175
                call    __puts
                ld      hl,global169    ; Get global S
                call    __puts
                call    __newline
; [207] 
; [208]   GotoXY(1, 10);
                ld      de,1            ; Literal 1
                push    de
                ld      de,10           ; Literal 10
                pop     hl
                call    __gotoxy
; [209]   Write(#27'L');
                ld      hl,string143
                call    __puts
; [210] 
; [211]   L := BigMin;
                ld      hl,global163    ; Get global L
                push    hl
                ld      hl,const81      ; Get global BigMin
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [212]   H := BigMax;
                ld      hl,global164    ; Get global H
                push    hl
                ld      hl,const82      ; Get global BigMax
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [213]   BigVal('1000000', I);
                ld      hl,string176
                call    __loadstr
                ld      hl,global161    ; Get global I
                push    hl
                call    proc95
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; [214]   BigDiv(H, I, R);
                ld      hl,global164    ; Get global H
                push    hl
                ld      hl,global161    ; Get global I
                push    hl
                ld      hl,global166    ; Get global R
                push    hl
                pop     bc
                pop     de
                pop     hl
                call    bigdiv
; [215] 
; [216]   BigVal('2', T);
                ld      de,50           ; Literal 50
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      d,e
                ld      e,1
                push    de
                ld      hl,global165    ; Get global T
                push    hl
                call    proc95
; Cleanup 256 bytes
                ld      hl,256          ; Clear
                add     hl,sp
                ld      sp,hl
; Cleanup 2 bytes
                pop     hl
; [217] 
; [218]   while BigCmp(L, H) <> 0 do
while177:
                push    hl
                ld      hl,global163    ; Get global L
                push    hl
                ld      hl,global164    ; Get global H
                push    hl
                call    func89
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
                push    hl
; [219]   begin
                pop     af
                jp      nc,false178
; [220]     I := L;
                ld      hl,global161    ; Get global I
                push    hl
                ld      hl,global163    ; Get global L
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [221]     J := H;
                ld      hl,global162    ; Get global J
                push    hl
                ld      hl,global164    ; Get global H
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [222]     BigSub(J, L);
                ld      hl,global162    ; Get global J
                push    hl
                ld      hl,global163    ; Get global L
                ld      de,hl
                pop     hl
                call    bigsub
; [223]     BigDiv(J, T, R);
                ld      hl,global162    ; Get global J
                push    hl
                ld      hl,global165    ; Get global T
                push    hl
                ld      hl,global166    ; Get global R
                push    hl
                pop     bc
                pop     de
                pop     hl
                call    bigdiv
; [224]     BigAdd(I, J);
                ld      hl,global161    ; Get global I
                push    hl
                ld      hl,global162    ; Get global J
                ld      de,hl
                pop     hl
                call    bigadd
; [225] 
; [226]     GotoXY(1, 10);
                ld      de,1            ; Literal 1
                push    de
                ld      de,10           ; Literal 10
                pop     hl
                call    __gotoxy
; [227]     Write(#27'L');
                ld      hl,string143
                call    __puts
; [228]     BigStr(L, S);
                ld      hl,global163    ; Get global L
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      hl,global169    ; Get global S
                push    hl
                call    proc101
; Cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [229]     Write(S:20);
                ld      hl,global169    ; Get global S
                call    __loadstr
                ld      de,20           ; Literal 20
                ld      bc,de
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                ld      hl,256
                add     hl,sp
                ld      sp,hl
; [230]     Write(' : ');
                ld      hl,string179
                call    __puts
; [231]     BigStr(I, S);
                ld      hl,global161    ; Get global I
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      hl,global169    ; Get global S
                push    hl
                call    proc101
; Cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [232]     Write(S:20);
                ld      hl,global169    ; Get global S
                call    __loadstr
                ld      de,20           ; Literal 20
                ld      bc,de
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                ld      hl,256
                add     hl,sp
                ld      sp,hl
; [233]     Write(' : ');
                ld      hl,string179
                call    __puts
; [234]     BigStr(H, S);
                ld      hl,global164    ; Get global H
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      hl,global169    ; Get global S
                push    hl
                call    proc101
; Cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [235]     Write(S:20);
                ld      hl,global169    ; Get global S
                call    __loadstr
                ld      de,20           ; Literal 20
                ld      bc,de
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                ld      hl,256
                add     hl,sp
                ld      sp,hl
; [236] 
; [237]     Humn^.Value := I;
                ld      hl,global160    ; Get global Humn
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,6            ; Literal 6
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global161    ; Get global I
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [238] 
; [239]     Eval(2, Root^.Left, Left);
                ld      de,2            ; Literal 2
                push    de
                ld      hl,global159    ; Get global Root
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,7            ; Literal 7
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,global167    ; Get global Left
                push    hl
                call    proc137
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [240]     Eval(2, Root^.Right, Right);
                ld      de,2            ; Literal 2
                push    de
                ld      hl,global159    ; Get global Root
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,9            ; Literal 9
                pop     hl
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,global168    ; Get global Right
                push    hl
                call    proc137
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [241] 
; [242]     C := BigCmp(Right, Left);
                ld      hl,global170    ; Get global C
                push    hl
                push    hl
                ld      hl,global168    ; Get global Right
                push    hl
                ld      hl,global167    ; Get global Left
                push    hl
                call    func89
; Cleanup 2 bytes
                pop     hl
; Cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),de
; [243]     if C < 0 then
                ld      hl,global170    ; Get global C
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [244]     begin
                pop     af
                jp      nc,false180
; [245]       L := I;
                ld      hl,global163    ; Get global L
                push    hl
                ld      hl,global161    ; Get global I
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [246]       BigAdd(L, BigOne);
                ld      hl,global163    ; Get global L
                push    hl
                ld      hl,const83      ; Get global BigOne
                ld      de,hl
                pop     hl
                call    bigadd
; [247]     end
; [248]     else if C > 0 then 
                jp      endif181
false180:
                ld      hl,global170    ; Get global C
                ld      de,(hl)
                push    de
                ld      de,0            ; Literal 0
                ld      hl,de
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
; [249]     begin 
                pop     af
                jp      nc,false182
; [250]       H := I;
                ld      hl,global164    ; Get global H
                push    hl
                ld      hl,global161    ; Get global I
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      bc,8            ; Store
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl              ; Store end
; [251]       BigSub(H, BigOne);
                ld      hl,global164    ; Get global H
                push    hl
                ld      hl,const83      ; Get global BigOne
                ld      de,hl
                pop     hl
                call    bigsub
; [252]     end
; [253]     else Break;
                jp      endif183
false182:
                jp      false178        ; Break
endif183:
endif181:
; [254]   end;
                jp      while177
false178:
; [255] 
; [256]   BigStr(I, S);
                ld      hl,global161    ; Get global I
                ld      de,hl
                ld      hl,-8
                add     hl,sp
                ld      sp,hl
                ex      hl,de
                ld      bc,8
                ldir                    ; Load end
                ld      hl,global169    ; Get global S
                push    hl
                call    proc101
; Cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; Cleanup 2 bytes
                pop     hl
; [257]   GotoXY(1, 7);
                ld      de,1            ; Literal 1
                push    de
                ld      de,7            ; Literal 7
                pop     hl
                call    __gotoxy
; [258]   WriteLn('Part 2: ', S);
                ld      hl,string184
                call    __puts
                ld      hl,global169    ; Get global S
                call    __puts
                call    __newline
; [259] 
; [260]   Write(#27'J');
                ld      hl,string185
                call    __puts
; [261]   Write(#27'e');
                ld      hl,string186
                call    __puts
; [262] end.
exit171:        call    __done
                ret
; 
string59:       db      0
; 
string122:      db      7,"Error: "
; 
string123:      db      11," not found."
; 
string126:      db      12,"INPUT   .TXT"
; 
string127:      db      10,"Loading..."
; 
string131:      db      12,"Resolving..."
; 
string143:      db      2,27,"L"
; 
string144:      db      3," = "
; 
string154:      db      6,"Oops: "
; 
string156:      db      4,"humn"
; 
string172:      db      2,27,"f"
; 
string173:      db      31,"*** AoC 2022.21 Monkey Math ***"
; 
string174:      db      4,"root"
; 
string175:      db      8,"Part 1: "
; 
string176:      db      7,"1000000"
; 
string179:      db      3," : "
; 
string184:      db      8,"Part 2: "
; 
string185:      db      2,27,"J"
; 
string186:      db      2,27,"e"
; 
display:        ds      32              ; Display
; 
eof:                                    ; End of file
; 
; HEAP:
; 
; end
; 


; +++ segments +++

#CODE          = $0100 =   256,  size = $6CDC = 27868

; +++ global symbols +++

AAC1         = $0716 =  1814          math48.z80:382 (unused)
AC1          = $0F11 =  3857          math48.z80:1913
ACLN2        = $0B49 =  2889          math48.z80:1210
ACPI         = $0B3F =  2879          math48.z80:1203
ADD1         = $0589 =  1417          math48.z80:52
ADD10        = $05F4 =  1524          math48.z80:134
ADD2         = $059C =  1436          math48.z80:71
ADD3         = $05B1 =  1457          math48.z80:89
ADD4         = $05BC =  1468          math48.z80:98
ADD5         = $05D0 =  1488          math48.z80:111
ADD6         = $05DA =  1498          math48.z80:117
ADD7         = $05DD =  1501          math48.z80:118
ADD8         = $05EE =  1518          math48.z80:129
ADD9         = $05EF =  1519          math48.z80:130
ADD9A        = $05F3 =  1523          math48.z80:132
ADDAC        = $0713 =  1811          math48.z80:379
ADDZ         = $05EB =  1515          math48.z80:127
ARCTAN       = $0AE7 =  2791          math48.z80:1137
ARCTK        = $0AC9 =  2761          math48.z80:1124
ATN          = $09F8 =  2552          math48.z80:1002
ATN1         = $0A0D =  2573          math48.z80:1019
ATN2         = $0A1B =  2587          math48.z80:1029
ATN3         = $0A30 =  2608          math48.z80:1040
ATN4         = $0A36 =  2614          math48.z80:1043
ATN5         = $0A51 =  2641          math48.z80:1060
ATN6         = $0A7F =  2687          math48.z80:1084
ATN7         = $0A8D =  2701          math48.z80:1095
ATN8         = $0A95 =  2709          math48.z80:1099
ATNK         = $0A99 =  2713          math48.z80:1105
CALC1        = $0B06 =  2822          math48.z80:1166
CALCS        = $0B02 =  2818          math48.z80:1164
CMP          = $0760 =  1888          math48.z80:466
CMP1         = $076A =  1898          math48.z80:475
CMP2         = $0774 =  1908          math48.z80:483
CMPAC        = $0747 =  1863          math48.z80:437
CNV1         = $0E6F =  3695          math48.z80:1798
CNV2         = $0E84 =  3716          math48.z80:1811
CNV3         = $0EA8 =  3752          math48.z80:1833
CNV4         = $0EAB =  3755          math48.z80:1836
CNV4A        = $0EC0 =  3776          math48.z80:1846
CNV4B        = $0EC2 =  3778          math48.z80:1848
CNV4C        = $0EDA =  3802          math48.z80:1866
CNV4D        = $0EE2 =  3810          math48.z80:1871
CNV5         = $0EE3 =  3811          math48.z80:1873
CNV6         = $0EF0 =  3824          math48.z80:1881
CNV6A        = $0EC6 =  3782          math48.z80:1850
CNVN         = $0E51 =  3665          math48.z80:1779
COMSER       = $0AED =  2797          math48.z80:1145
CON10        = $0DEB =  3563          math48.z80:1722
COS          = $0820 =  2080          math48.z80:653
CPM          = $0001 =     1          monkey.z80:4 (unused)
DIGI1        = $0C32 =  3122          math48.z80:1428
DIGI2        = $0C3E =  3134          math48.z80:1434
DIGITS       = $0BE8 =  3048          math48.z80:1374
DIGTST       = $0F0A =  3850          math48.z80:1905
DIVI1        = $062C =  1580          math48.z80:192
DIVI2        = $0635 =  1589          math48.z80:197
DIVI3        = $0648 =  1608          math48.z80:211
DIVI4        = $0654 =  1620          math48.z80:219
DIVI5        = $065D =  1629          math48.z80:224
DIVI6        = $0669 =  1641          math48.z80:233
DZERO        = $0BE2 =  3042          math48.z80:1371
EQUAL        = $0B53 =  2899          math48.z80:1217
EXP          = $0987 =  2439          math48.z80:920
EXP1         = $09AB =  2475          math48.z80:945 (unused)
EXP3         = $09B8 =  2488          math48.z80:951 (unused)
EXP4         = $09BD =  2493          math48.z80:956
EXP5         = $09BF =  2495          math48.z80:958
EXP6         = $09C2 =  2498          math48.z80:960
EXPK         = $09CE =  2510          math48.z80:969
EXPN         = $0080 =   128          math48.z80:39
EXPS1        = $06D6 =  1750          math48.z80:324
EXPS2        = $06DA =  1754          math48.z80:327
EXPS3        = $06F1 =  1777          math48.z80:343
EXPSGN       = $06CE =  1742          math48.z80:319
FIX          = $0B5B =  2907          math48.z80:1229
FIX1         = $0B65 =  2917          math48.z80:1236
FIX2         = $0B71 =  2929          math48.z80:1244
FIX3         = $0B7E =  2942          math48.z80:1252
FIX4         = $0B81 =  2945          math48.z80:1256
FLOAT        = $0B85 =  2949          math48.z80:1262
FLT1         = $0B95 =  2965          math48.z80:1274
FLT2         = $0B9E =  2974          math48.z80:1280
FLT3         = $0BA8 =  2984          math48.z80:1286
FPADD        = $0582 =  1410          math48.z80:47
FPDIV        = $0611 =  1553          math48.z80:165
FPMUL        = $0670 =  1648          math48.z80:242
FPNEG        = $0607 =  1543          math48.z80:152
FPSUB        = $05FA =  1530          math48.z80:144
FRAC         = $07B2 =  1970          math48.z80:546
FSTRR        = $0BAD =  2989          math48.z80:1325
FSTRS        = $0BB4 =  2996          math48.z80:1338
FWIDTH       = $000F =    15          math48.z80:42
GDTST        = $0F07 =  3847          math48.z80:1904
GETCIX       = $0B2C =  2860          math48.z80:1193
GTNCIX       = $0B27 =  2855          math48.z80:1191
INT          = $077E =  1918          math48.z80:495
INT1         = $078E =  1934          math48.z80:508
INT2         = $07AF =  1967          math48.z80:539
IWIDTH       = $00F0 =   240          math48.z80:41
LEFT         = $0708 =  1800          math48.z80:370
LN           = $08EB =  2283          math48.z80:806
LN1          = $0940 =  2368          math48.z80:864
LNK          = $0958 =  2392          math48.z80:880
LOG          = $08D4 =  2260          math48.z80:783
M10A         = $0E4A =  3658          math48.z80:1771
MFACT        = $0EF3 =  3827          math48.z80:1885
MOD          = $07C4 =  1988          math48.z80:564
MORED        = $0DA8 =  3496          math48.z80:1679
MUL1         = $068C =  1676          math48.z80:267
MUL10        = $0E27 =  3623          math48.z80:1746
MUL2         = $0693 =  1683          math48.z80:271
MUL3         = $069B =  1691          math48.z80:276
MUL4         = $06B7 =  1719          math48.z80:296
MUL5         = $06BA =  1722          math48.z80:300
MUL5A        = $06BB =  1723          math48.z80:301
OEX1         = $0D69 =  3433          math48.z80:1636
OEX2         = $0D6F =  3439          math48.z80:1639
OM1          = $0CC6 =  3270          math48.z80:1536
OM10         = $0D1F =  3359          math48.z80:1592
OM11         = $0D28 =  3368          math48.z80:1598
OM12         = $0D2F =  3375          math48.z80:1602
OM13         = $0D3F =  3391          math48.z80:1612
OM14         = $0D48 =  3400          math48.z80:1618
OM15         = $0D54 =  3412          math48.z80:1624
OM2          = $0CDE =  3294          math48.z80:1552
OM3          = $0CDF =  3295          math48.z80:1553
OM4          = $0CE4 =  3300          math48.z80:1556
OM5          = $0CEF =  3311          math48.z80:1565
OM6          = $0CF9 =  3321          math48.z80:1571
OM7          = $0D09 =  3337          math48.z80:1579
OM8          = $0D15 =  3349          math48.z80:1585
OM9          = $0D18 =  3352          math48.z80:1587
OUTM         = $0CBE =  3262          math48.z80:1530
OUTN1        = $0BC3 =  3011          math48.z80:1346
POPA1        = $0D7E =  3454          math48.z80:1647
POPALL       = $0D7F =  3455          math48.z80:1648
PWR          = $097C =  2428          math48.z80:898
RIGHT        = $06FC =  1788          math48.z80:360
ROU1         = $0C8A =  3210          math48.z80:1490
ROU2         = $0C90 =  3216          math48.z80:1494
ROU3         = $0C98 =  3224          math48.z80:1501
ROU4         = $0C9F =  3231          math48.z80:1506
ROU5         = $0CAE =  3246          math48.z80:1517
ROU6         = $0CB7 =  3255          math48.z80:1524
ROUND        = $0C7D =  3197          math48.z80:1481 (unused)
SAC1         = $0730 =  1840          math48.z80:411 (unused)
SC1          = $0BF4 =  3060          math48.z80:1387
SC2          = $0C0E =  3086          math48.z80:1409
SC3          = $0C21 =  3105          math48.z80:1418
SC4          = $0C2A =  3114          math48.z80:1423
SIGN         = $0080 =   128          math48.z80:38
SIN          = $082E =  2094          math48.z80:677
SIN1A        = $0847 =  2119          math48.z80:695 (unused)
SIN2         = $084E =  2126          math48.z80:699
SIN3         = $085A =  2138          math48.z80:707
SIN4         = $0867 =  2151          math48.z80:716
SIN7         = $08B2 =  2226          math48.z80:762
SIN7A        = $08A7 =  2215          math48.z80:754
SINC         = $0832 =  2098          math48.z80:681
SINK         = $08B6 =  2230          math48.z80:767
SLEFT        = $0707 =  1799          math48.z80:369
SQR          = $07CE =  1998          math48.z80:580
SQR1         = $07E9 =  2025          math48.z80:603
SQR2         = $0809 =  2057          math48.z80:629
SRIGHT       = $06FB =  1787          math48.z80:359
STOA         = $0DA2 =  3490          math48.z80:1673
STODIG       = $0D96 =  3478          math48.z80:1667
STOZ         = $0DA0 =  3488          math48.z80:1672
SUB1         = $0601 =  1537          math48.z80:149
SUBAC        = $072D =  1837          math48.z80:408
TAN          = $080C =  2060          math48.z80:636
TENF         = $0DB0 =  3504          math48.z80:1687
TF1          = $0DB7 =  3511          math48.z80:1691
TF2          = $0DC3 =  3523          math48.z80:1697
TF3          = $0DD8 =  3544          math48.z80:1708
TF4          = $0DE2 =  3554          math48.z80:1714
ZERO         = $06F3 =  1779          math48.z80:348
__abs16      = $021C =   540          pl0.z80:292 (unused)
__assert     = $1246 =  4678          pl0.z80:1785 (unused)
__assert1    = $1252 =  4690          pl0.z80:1793
__assert_msg_1 = $1273 =  4723          pl0.z80:1808
__assert_msg_2 = $128C =  4748          pl0.z80:1809
__assertfailed = $1296 =  4758          pl0.z80:1812
__assertpassed = $1294 =  4756          pl0.z80:1811
__atof       = $0F8D =  3981          pl0.z80:1095
__atoi       = $12C3 =  4803          pl0.z80:1861
__atoi_done  = $12E9 =  4841          pl0.z80:1885
__atoi_loop  = $12D3 =  4819          pl0.z80:1871
__atoi_skip  = $12E5 =  4837          pl0.z80:1882
__begcmp     = $025A =   602          pl0.z80:372
__boolean0   = $0128 =   296          pl0.z80:32
__boolean1   = $0123 =   291          pl0.z80:31
__boolean_enum = $012E =   302          pl0.z80:33 (unused)
__buffer     = $0103 =   259          pl0.z80:19
__chkde      = $01A7 =   423          pl0.z80:182
__chklen     = $036A =   874          pl0.z80:587 (unused)
__clrscr     = $132F =  4911          pl0.z80:1959
__clrscr_str = $1336 =  4918          pl0.z80:1962
__cmplen     = $0266 =   614          pl0.z80:384
__cmplp      = $025F =   607          pl0.z80:377
__cmplp2     = $02F8 =   760          pl0.z80:485
__cnt1ok     = $033E =   830          pl0.z80:546
__cnt2ok     = $034A =   842          pl0.z80:553
__cntok      = $03DF =   991          pl0.z80:686
__concat     = $0437 =  1079          pl0.z80:788 (unused)
__copy       = $0470 =  1136          pl0.z80:830
__count      = $01FE =   510          pl0.z80:247 (unused)
__cpyerr     = $035E =   862          pl0.z80:572
__cur_off_str = $134C =  4940          pl0.z80:1987
__cur_on_str = $1342 =  4930          pl0.z80:1976
__cursor_off = $1345 =  4933          pl0.z80:1984 (unused)
__cursor_on  = $133B =  4923          pl0.z80:1973 (unused)
__delerr     = $03F4 =  1012          pl0.z80:706
__delete     = $0497 =  1175          pl0.z80:862 (unused)
__div10      = $0208 =   520          pl0.z80:273
__div10a     = $0212 =   530          pl0.z80:282
__div10b     = $0219 =   537          pl0.z80:288
__divide     = $01DA =   474          pl0.z80:220
__docat      = $02AB =   683          pl0.z80:432
__dodiv      = $01B2 =   434          pl0.z80:191
__done       = $13FD =  5117          pl0.z80:2301
__dorem      = $01C3 =   451          pl0.z80:202
__drop       = $01F0 =   496          pl0.z80:234
__dvloop     = $01E2 =   482          pl0.z80:225
__erexit     = $035B =   859          pl0.z80:567
__exit       = $02B7 =   695          pl0.z80:440
__flteq      = $0F50 =  3920          pl0.z80:1049 (unused)
__flteq0     = $0F55 =  3925          pl0.z80:1052 (unused)
__flteq1     = $0F59 =  3929          pl0.z80:1055
__fltleq     = $0F77 =  3959          pl0.z80:1079 (unused)
__fltleq0    = $0F7E =  3966          pl0.z80:1083 (unused)
__fltleq1    = $0F82 =  3970          pl0.z80:1086
__fltlt      = $0F6A =  3946          pl0.z80:1069 (unused)
__fltlt0     = $0F6F =  3951          pl0.z80:1072 (unused)
__fltlt1     = $0F73 =  3955          pl0.z80:1075
__fltneq     = $0F5D =  3933          pl0.z80:1059 (unused)
__fltneq0    = $0F62 =  3938          pl0.z80:1062 (unused)
__fltneq1    = $0F66 =  3942          pl0.z80:1065
__fltpwr2    = $0F86 =  3974          pl0.z80:1090 (unused)
__found      = $0307 =   775          pl0.z80:497
__freemem    = $13DC =  5084          pl0.z80:2234
__ftoa       = $0F9D =  3997          pl0.z80:1104
__ftoaerr    = $0FE9 =  4073          pl0.z80:1128
__ftoalp     = $0FB4 =  4020          pl0.z80:1115
__ftoaok     = $0FAE =  4014          pl0.z80:1112
__ftoatmp    = $0FC8 =  4040          pl0.z80:1126
__get_heap_bytes = $13F2 =  5106          pl0.z80:2254 (unused)
__get_heap_start = $13EE =  5102          pl0.z80:2250 (unused)
__getmem     = $1353 =  4947          pl0.z80:2147
__getn       = $121F =  4639          pl0.z80:1725 (unused)
__gotoxy     = $1317 =  4887          pl0.z80:1933
__gotoxy_str = $132A =  4906          pl0.z80:1942
__heapptr    = $1351 =  4945          pl0.z80:2142
__idx0       = $0366 =   870          pl0.z80:582 (unused)
__idxl1      = $038E =   910          pl0.z80:618
__idxlen     = $037E =   894          pl0.z80:603
__index      = $0313 =   787          pl0.z80:511
__init       = $13FC =  5116          pl0.z80:2269
__inserr     = $03B9 =   953          pl0.z80:653
__insert     = $0483 =  1155          pl0.z80:845 (unused)
__int16_case = $0156 =   342          pl0.z80:97 (unused)
__int16_eq   = $0132 =   306          pl0.z80:41
__int16_geq  = $014A =   330          pl0.z80:84
__int16_geq_of = $0153 =   339          pl0.z80:91
__int16_lt   = $013E =   318          pl0.z80:67
__int16_lt_of = $0147 =   327          pl0.z80:74
__int16_neq  = $0138 =   312          pl0.z80:54
__int_shl    = $0168 =   360          pl0.z80:115 (unused)
__int_shl1   = $016C =   364          pl0.z80:119
__int_shr    = $0173 =   371          pl0.z80:129 (unused)
__int_shr1   = $0177 =   375          pl0.z80:133
__itoa       = $1298 =  4760          pl0.z80:1821
__itoa_loop1 = $12AD =  4781          pl0.z80:1834
__itoa_loop2 = $12BB =  4795          pl0.z80:1844
__length     = $04F6 =  1270          pl0.z80:936
__lenok      = $02A4 =   676          pl0.z80:428
__lenok2     = $0395 =   917          pl0.z80:622
__lens1      = $026E =   622          pl0.z80:389
__lens2      = $026F =   623          pl0.z80:391
__loadfp     = $0F1B =  3867          pl0.z80:1021 (unused)
__loadstr    = $0503 =  1283          pl0.z80:948
__malloc     = $1364 =  4964          pl0.z80:2162
__malloc_check_larger = $1388 =  5000          pl0.z80:2186
__malloc_error_message = $13CE =  5070          pl0.z80:2230
__malloc_infinite_loop = $13CB =  5067          pl0.z80:2228
__malloc_loop = $136B =  4971          pl0.z80:2166
__malloc_next = $13B2 =  5042          pl0.z80:2216
__malloc_out_of_memory = $13C5 =  5061          pl0.z80:2225
__maxlen     = $035D =   861          pl0.z80:570
__movestr    = $0526 =  1318          pl0.z80:979
__movestr_1  = $052C =  1324          pl0.z80:984
__mul10      = $01FF =   511          pl0.z80:256
__mul16      = $017E =   382          pl0.z80:146
__mul16a     = $0185 =   389          pl0.z80:150
__mul16b     = $018C =   396          pl0.z80:154
__mvesub     = $03AE =   942          pl0.z80:645
__neg16      = $021F =   543          pl0.z80:297 (unused)
__newline    = $112A =  4394          pl0.z80:1479
__notfnd     = $030B =   779          pl0.z80:500
__okexit     = $0359 =   857          pl0.z80:564 (unused)
__okexit2    = $03F2 =  1010          pl0.z80:703 (unused)
__poke       = $134F =  4943          pl0.z80:2001 (unused)
__pos        = $045D =  1117          pl0.z80:815 (unused)
__putc       = $1113 =  4371          pl0.z80:1438
__putc_fmt   = $11E5 =  4581          pl0.z80:1674 (unused)
__pute       = $11DB =  4571          pl0.z80:1664 (unused)
__pute_fmt   = $1215 =  4629          pl0.z80:1708 (unused)
__putf       = $0FEF =  4079          pl0.z80:1131 (unused)
__putf_exp   = $0FFB =  4091          pl0.z80:1139 (unused)
__putf_exp_0 = $1006 =  4102          pl0.z80:1147
__putf_exp_1 = $100F =  4111          pl0.z80:1153
__putf_fix   = $101B =  4123          pl0.z80:1162 (unused)
__putf_fix_1 = $101E =  4126          pl0.z80:1169 (unused)
__putn       = $11CC =  4556          pl0.z80:1649
__putn_fmt   = $1205 =  4613          pl0.z80:1699 (unused)
__puts       = $111A =  4378          pl0.z80:1459
__puts_fmt   = $11F0 =  4592          pl0.z80:1682
__puts_fmt_1 = $1201 =  4609          pl0.z80:1695
__puts_fmt_loop = $11F8 =  4600          pl0.z80:1689
__putschk    = $1126 =  4390          pl0.z80:1468
__putsloop   = $111E =  4382          pl0.z80:1462
__ralign     = $11A8 =  4520          pl0.z80:1599
__ralign1    = $11AE =  4526          pl0.z80:1605
__ralign2    = $11C7 =  4551          pl0.z80:1631
__rand16     = $022E =   558          pl0.z80:319
__random     = $0226 =   550          pl0.z80:311 (unused)
__recalc     = $0335 =   821          pl0.z80:539
__s1adr      = $02C3 =   707          pl0.z80:447
__s1len      = $02C5 =   709          pl0.z80:449
__s2len      = $02C6 =   710          pl0.z80:451
__sdiv16     = $0194 =   404          pl0.z80:169
__setadd     = $1092 =  4242          pl0.z80:1282 (unused)
__setadd1    = $109D =  4253          pl0.z80:1289
__seteq      = $10CD =  4301          pl0.z80:1352 (unused)
__seteq1     = $10D8 =  4312          pl0.z80:1359
__seteq2     = $10E4 =  4324          pl0.z80:1368
__setexclude = $1088 =  4232          pl0.z80:1266 (unused)
__setgeq     = $1105 =  4357          pl0.z80:1408 (unused)
__setin_new  = $102C =  4140          pl0.z80:1190 (unused)
__setinclude = $1080 =  4224          pl0.z80:1258 (unused)
__setleq     = $10E8 =  4328          pl0.z80:1379 (unused)
__setleq1    = $10F3 =  4339          pl0.z80:1386
__setleq2    = $1101 =  4353          pl0.z80:1397
__setmember  = $106A =  4202          pl0.z80:1244 (unused)
__setmul     = $10BA =  4282          pl0.z80:1329 (unused)
__setmul1    = $10C5 =  4293          pl0.z80:1336
__setoff     = $1043 =  4163          pl0.z80:1209
__setoff1    = $1053 =  4179          pl0.z80:1221
__setoff2    = $105B =  4187          pl0.z80:1226
__setoff3    = $1067 =  4199          pl0.z80:1233
__setsub     = $10A5 =  4261          pl0.z80:1305 (unused)
__setsub1    = $10B0 =  4272          pl0.z80:1312
__slen       = $0311 =   785          pl0.z80:507 (unused)
__slp1       = $02E5 =   741          pl0.z80:476
__slp2       = $0303 =   771          pl0.z80:494
__squot      = $01FC =   508          pl0.z80:245
__srem       = $01FD =   509          pl0.z80:246
__storefp    = $0F35 =  3893          pl0.z80:1035
__storestr   = $0512 =  1298          pl0.z80:963
__str_fix_1  = $117E =  4478          pl0.z80:1556 (unused)
__str_int    = $04A9 =  1193          pl0.z80:878 (unused)
__stradd     = $0450 =  1104          pl0.z80:806
__strc       = $1154 =  4436          pl0.z80:1517 (unused)
__strcat     = $0270 =   624          pl0.z80:396
__strcmp     = $024E =   590          pl0.z80:364
__strcpy     = $0314 =   788          pl0.z80:516
__strdel     = $03BA =   954          pl0.z80:657
__stre       = $119E =  4510          pl0.z80:1579 (unused)
__streq      = $03F5 =  1013          pl0.z80:715
__streq0     = $0405 =  1029          pl0.z80:725
__streq1     = $0409 =  1033          pl0.z80:730
__strf       = $116B =  4459          pl0.z80:1537 (unused)
__strf2      = $117B =  4475          pl0.z80:1549 (unused)
__strgov     = $02C7 =   711          pl0.z80:453
__string     = $030D =   781          pl0.z80:503
__strins     = $035F =   863          pl0.z80:576
__strleq     = $0421 =  1057          pl0.z80:768 (unused)
__strleq0    = $042F =  1071          pl0.z80:776 (unused)
__strleq1    = $0433 =  1075          pl0.z80:781
__strlt      = $040D =  1037          pl0.z80:743 (unused)
__strlt0     = $0419 =  1049          pl0.z80:750 (unused)
__strlt1     = $041D =  1053          pl0.z80:755
__strn       = $1135 =  4405          pl0.z80:1495
__strn_fmt   = $1148 =  4424          pl0.z80:1507 (unused)
__strpos     = $02C8 =   712          pl0.z80:457
__strs       = $115C =  4444          pl0.z80:1526 (unused)
__sublen     = $0312 =   786          pl0.z80:509
__substg     = $030F =   783          pl0.z80:505
__textbg     = $1306 =  4870          pl0.z80:1914 (unused)
__textbg_str = $1313 =  4883          pl0.z80:1920
__textfg     = $12F5 =  4853          pl0.z80:1895 (unused)
__textfg_str = $1302 =  4866          pl0.z80:1901
__toolng     = $028F =   655          pl0.z80:416
__trunc      = $0374 =   884          pl0.z80:595
__trunc2     = $03D7 =   983          pl0.z80:679
__udiv16     = $01CF =   463          pl0.z80:212
__val_float  = $04E0 =  1248          pl0.z80:911 (unused)
__val_int    = $04C1 =  1217          pl0.z80:893
_end         = $6DDC = 28124          monkey.z80:6 (unused)
_size        = $6CDC = 27868          monkey.z80:6 (unused)
bigadd       = $204E =  8270          bigint.asm:10
bigdiv       = $20DE =  8414          bigint.asm:136
bigmul       = $206B =  8299          bigint.asm:51
bigsub       = $205C =  8284          bigint.asm:30
break104     = $2534 =  9524          monkey.z80:2471 (unused)
case146      = $65A8 = 26024          monkey.z80:3792
case148      = $65D3 = 26067          monkey.z80:3812
case150      = $65FE = 26110          monkey.z80:3832
case152      = $6629 = 26153          monkey.z80:3852
const138     = $62E0 = 25312          monkey.z80:3525
const81      = $219D =  8605          monkey.z80:1952
const82      = $21A5 =  8613          monkey.z80:1955
const83      = $21AD =  8621          monkey.z80:1958
const84      = $21B5 =  8629          monkey.z80:1961
display      = $6DBC = 28092          monkey.z80:4801
end145       = $6674 = 26228          monkey.z80:3893
endif136     = $62C6 = 25286          monkey.z80:3500
endif141     = $67D0 = 26576          monkey.z80:4110
endif181     = $6CDA = 27866          monkey.z80:4716
endif183     = $6CDA = 27866          monkey.z80:4715
eof          = $6DDC = 28124          monkey.z80:4803
exit102      = $2534 =  9524          monkey.z80:2473 (unused)
exit107      = $5C84 = 23684          monkey.z80:2575 (unused)
exit112      = $5D60 = 23904          monkey.z80:2702 (unused)
exit114      = $5E5A = 24154          monkey.z80:2845 (unused)
exit118      = $5FB9 = 24505          monkey.z80:3031
exit125      = $62D7 = 25303          monkey.z80:3515 (unused)
exit139      = $67D0 = 26576          monkey.z80:4112 (unused)
exit171      = $6D1F = 27935          monkey.z80:4760 (unused)
exit3        = $1450 =  5200          monkey.z80:128 (unused)
exit40       = $17AF =  6063          monkey.z80:707 (unused)
exit48       = $18CA =  6346          monkey.z80:870 (unused)
exit5        = $1524 =  5412          monkey.z80:244 (unused)
exit50       = $1A19 =  6681          monkey.z80:1059 (unused)
exit52       = $1ABA =  6842          monkey.z80:1147 (unused)
exit54       = $1BB1 =  7089          monkey.z80:1281 (unused)
exit58       = $1CC5 =  7365          monkey.z80:1438 (unused)
exit66       = $1D66 =  7526          monkey.z80:1526 (unused)
exit68       = $1E2C =  7724          monkey.z80:1632 (unused)
exit71       = $1F15 =  7957          monkey.z80:1762 (unused)
exit76       = $1FB2 =  8114          monkey.z80:1848 (unused)
exit79       = $2045 =  8261          monkey.z80:1937 (unused)
exit9        = $1617 =  5655          monkey.z80:377 (unused)
exit90       = $22BE =  8894          monkey.z80:2118
exit96       = $2467 =  9319          monkey.z80:2356
false11      = $15FD =  5629          monkey.z80:363
false116     = $5E31 = 24113          monkey.z80:2823
false12      = $15D7 =  5591          monkey.z80:342
false120     = $5F8E = 24462          monkey.z80:3010
false121     = $5F29 = 24361          monkey.z80:2959
false129     = $60C9 = 24777          monkey.z80:3196
false130     = $6055 = 24661          monkey.z80:3131
false133     = $62CA = 25290          monkey.z80:3504
false134     = $613C = 24892          monkey.z80:3267
false135     = $6270 = 25200          monkey.z80:3446
false140     = $644E = 25678          monkey.z80:3593
false142     = $6587 = 25991          monkey.z80:3771
false155     = $66CA = 26314          monkey.z80:3943
false157     = $67D0 = 26576          monkey.z80:4108
false158     = $67D0 = 26576          monkey.z80:4107
false178     = $6CDD = 27869          monkey.z80:4719
false180     = $6C88 = 27784          monkey.z80:4669
false182     = $6CD7 = 27863          monkey.z80:4713
false55      = $1B11 =  6929          monkey.z80:1197
false56      = $1B9B =  7067          monkey.z80:1267
false61      = $1CC5 =  7365          monkey.z80:1436
false62      = $1C4A =  7242          monkey.z80:1371
false63      = $1C68 =  7272          monkey.z80:1388
false64      = $1CC2 =  7362          monkey.z80:1433
false69      = $1DBD =  7613          monkey.z80:1575
false7       = $150A =  5386          monkey.z80:230
false77      = $1F6C =  8044          monkey.z80:1810
false80      = $2011 =  8209          monkey.z80:1908
false94      = $2286 =  8838          monkey.z80:2084
false97      = $2372 =  9074          monkey.z80:2219
forbreak109  = $5C83 = 23683          monkey.z80:2573
forbreak42   = $1700 =  5888          monkey.z80:616
forbreak45   = $17AE =  6062          monkey.z80:705
forbreak73   = $1EE8 =  7912          monkey.z80:1733
forbreak92   = $22AC =  8876          monkey.z80:2107
forbreak99   = $2466 =  9318          monkey.z80:2354
forloop108   = $5C32 = 23602          monkey.z80:2533
forloop41    = $1681 =  5761          monkey.z80:551
forloop44    = $172F =  5935          monkey.z80:640
forloop72    = $1E8A =  7818          monkey.z80:1686
forloop91    = $21FE =  8702          monkey.z80:2013
forloop98    = $23D9 =  9177          monkey.z80:2277
fornext100   = $243E =  9278          monkey.z80:2332 (unused)
fornext110   = $5C52 = 23634          monkey.z80:2550 (unused)
fornext43    = $16CF =  5839          monkey.z80:593 (unused)
fornext46    = $177D =  6013          monkey.z80:682 (unused)
fornext74    = $1EB7 =  7863          monkey.z80:1710 (unused)
fornext93    = $2286 =  8838          monkey.z80:2086 (unused)
func111      = $5C8D = 23693          monkey.z80:2588
func117      = $5E63 = 24163          monkey.z80:2859
func4        = $1459 =  5209          monkey.z80:142 (unused)
func53       = $1AC3 =  6851          monkey.z80:1160
func75       = $1F1E =  7966          monkey.z80:1773
func8        = $152D =  5421          monkey.z80:258 (unused)
func89       = $21BD =  8637          monkey.z80:1980
global105    = $253D =  9533          monkey.z80:2494
global159    = $67D9 = 26585          monkey.z80:4121
global160    = $67DB = 26587          monkey.z80:4122
global161    = $67DD = 26589          monkey.z80:4124
global162    = $67E5 = 26597          monkey.z80:4125
global163    = $67ED = 26605          monkey.z80:4126
global164    = $67F5 = 26613          monkey.z80:4127
global165    = $67FD = 26621          monkey.z80:4128
global166    = $6805 = 26629          monkey.z80:4129
global167    = $680D = 26637          monkey.z80:4130
global168    = $6815 = 26645          monkey.z80:4131
global169    = $681D = 26653          monkey.z80:4133
global170    = $691D = 26909          monkey.z80:4135
main         = $691F = 26911          monkey.z80:4140
proc101      = $2470 =  9328          monkey.z80:2369
proc106      = $5BEF = 23535          monkey.z80:2502
proc113      = $5D69 = 23913          monkey.z80:2716
proc124      = $5FC2 = 24514          monkey.z80:3047
proc137      = $63E0 = 25568          monkey.z80:3533
proc2        = $1401 =  5121          monkey.z80:92
proc39       = $1620 =  5664          monkey.z80:502
proc47       = $17B8 =  6072          monkey.z80:720
proc49       = $18D3 =  6355          monkey.z80:883 (unused)
proc51       = $1A22 =  6690          monkey.z80:1072
proc57       = $1BBA =  7098          monkey.z80:1294
proc65       = $1CCE =  7374          monkey.z80:1451
proc67       = $1D6F =  7535          monkey.z80:1538
proc70       = $1E35 =  7733          monkey.z80:1645 (unused)
proc78       = $1FBB =  8123          monkey.z80:1861
proc95       = $22C7 =  8903          monkey.z80:2133
repeat103    = $249B =  9371          monkey.z80:2390
seed1        = $024A =   586          pl0.z80:352
seed2        = $024C =   588          pl0.z80:353
string122    = $6D24 = 27940          monkey.z80:4765
string123    = $6D2C = 27948          monkey.z80:4767
string126    = $6D38 = 27960          monkey.z80:4769
string127    = $6D45 = 27973          monkey.z80:4771
string131    = $6D50 = 27984          monkey.z80:4773
string143    = $6D5D = 27997          monkey.z80:4775
string144    = $6D60 = 28000          monkey.z80:4777
string154    = $6D64 = 28004          monkey.z80:4779
string156    = $6D6B = 28011          monkey.z80:4781
string172    = $6D70 = 28016          monkey.z80:4783
string173    = $6D73 = 28019          monkey.z80:4785
string174    = $6D93 = 28051          monkey.z80:4787
string175    = $6D98 = 28056          monkey.z80:4789
string176    = $6DA1 = 28065          monkey.z80:4791
string179    = $6DA9 = 28073          monkey.z80:4793
string184    = $6DAD = 28077          monkey.z80:4795
string185    = $6DB6 = 28086          monkey.z80:4797
string186    = $6DB9 = 28089          monkey.z80:4799
string59     = $6D23 = 27939          monkey.z80:4763
test147      = $65C6 = 26054          monkey.z80:3806
test149      = $65F1 = 26097          monkey.z80:3826
test151      = $661C = 26140          monkey.z80:3846
test153      = $6651 = 26193          monkey.z80:3872
while10      = $1568 =  5480          monkey.z80:285
while115     = $5DC1 = 24001          monkey.z80:2762
while119     = $5EC4 = 24260          monkey.z80:2906
while128     = $6005 = 24581          monkey.z80:3085
while132     = $60EC = 24812          monkey.z80:3221
while177     = $6A6B = 27243          monkey.z80:4345
while6       = $1494 =  5268          monkey.z80:169
while60      = $1BE5 =  7141          monkey.z80:1315

; +++ local symbols +++

bigadd1 = $2052 =  8274          bigint.asm:15

; +++ local symbols +++

bigsub1 = $2061 =  8289          bigint.asm:36

; +++ local symbols +++

addlp   = $20AC =  8364          bigint.asm:101
count   = $20D0 =  8400          bigint.asm:127
deccnt  = $20B4 =  8372          bigint.asm:110
endhp   = $20D2 =  8402          bigint.asm:128
exit    = $20CE =  8398          bigint.asm:123
hiprod  = $20D6 =  8406          bigint.asm:130
loop    = $208E =  8334          bigint.asm:78
mlier   = $20D4 =  8404          bigint.asm:129
srailp  = $209A =  8346          bigint.asm:89
srplp   = $2092 =  8338          bigint.asm:81
zerolp  = $2088 =  8328          bigint.asm:72
zeropd  = $2084 =  8324          bigint.asm:69 (unused)

; +++ local symbols +++

chkolp  = $2111 =  8465          bigint.asm:171
cont    = $2135 =  8501          bigint.asm:198
count   = $218A =  8586          bigint.asm:254
deccnt  = $2122 =  8482          bigint.asm:188 (unused)
dvend   = $2182 =  8578          bigint.asm:250
dvsor   = $2184 =  8580          bigint.asm:251
erexit  = $2173 =  8563          bigint.asm:235
exit    = $2178 =  8568          bigint.asm:242
hdeptr  = $2186 =  8582          bigint.asm:252
hide1   = $218D =  8589          bigint.asm:256
hide2   = $2195 =  8597          bigint.asm:257
loop    = $2119 =  8473          bigint.asm:180
odeptr  = $2188 =  8584          bigint.asm:253
okexit  = $2177 =  8567          bigint.asm:239
sllp1   = $211D =  8477          bigint.asm:183
sllp2   = $2139 =  8505          bigint.asm:201
subcnt  = $218C =  8588          bigint.asm:255
sublp   = $214F =  8527          bigint.asm:213
zerolp  = $20FA =  8442          bigint.asm:155


total time: 0.0472 sec.
no errors
